<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.20">
<meta name="author" content="System: v0.6.0-dev | Docbook: v250612-2 | www.kernel0.org">
<title>RK0: The Real-Time Kernel '0'</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ul.square{list-style-type:square}
ul.circle ul:not([class]),ul.disc ul:not([class]),ul.square ul:not([class]){list-style:inherit}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;outline:none;-webkit-tap-highlight-color:transparent}
details>summary::-webkit-details-marker{display:none}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:first-child,.sidebarblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child,.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos,pre.pygments .linenos{border-right:1px solid;opacity:.35;padding-right:.5em;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}
pre.pygments span.linenos{display:inline-block;margin-right:.75em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all>*>tr,table.stripes-odd>*>tr:nth-of-type(odd),table.stripes-even>*>tr:nth-of-type(even),table.stripes-hover>*>tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
li>p:empty:only-child::before{content:"";display:inline-block}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,td.hdlist1,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/styles/github.min.css">
</head>
<body class="book toc2 toc-left data-line-1">
<div id="header">
<h1>RK0: The Real-Time Kernel '0'</h1>
<div class="details">
<span id="author" class="author">System: v0.6.0-dev | Docbook: v250612-2 | www.kernel0.org</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the_kernel_on_a_glance">1. THE KERNEL ON A GLANCE</a>
<ul class="sectlevel2">
<li><a href="#the_design_approach">1.1. The design approach</a>
<ul class="sectlevel3">
<li><a href="#architecture">1.1.1. Architecture</a></li>
<li><a href="#suitable_applications">1.1.2. Suitable Applications</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#core_mechanisms">2. <strong><em>Core Mechanisms</em></strong></a>
<ul class="sectlevel2">
<li><a href="#scheduler">2.1. Scheduler</a>
<ul class="sectlevel3">
<li><a href="#scheduler_data_structures">2.1.1. Scheduler Data Structures</a>
<ul class="sectlevel4">
<li><a href="#task_control_block">2.1.1.1. Task Control Block</a></li>
<li><a href="#task_queues">2.1.1.2. Task Queues</a></li>
<li><a href="#ready_queue_table">2.1.1.3. Ready Queue Table</a></li>
<li><a href="#waiting_queues">2.1.1.4. Waiting Queues</a></li>
</ul>
</li>
<li><a href="#the_scheduling_algorithm">2.1.2. The scheduling algorithm</a></li>
<li><a href="#scheduler_determinism">2.1.3. Scheduler Determinism</a>
<ul class="sectlevel4">
<li><a href="#preemptive_scheduling">2.1.3.1. Preemptive Scheduling</a></li>
<li><a href="#cooperative_scheduling">2.1.3.2. Cooperative Scheduling</a></li>
</ul>
</li>
<li><a href="#handling_the_scheduler">2.1.4. Handling the scheduler</a></li>
</ul>
</li>
<li><a href="#timers">2.2. Timers</a>
<ul class="sectlevel3">
<li><a href="#sleep_timers">2.2.1. Sleep Timers</a></li>
<li><a href="#blocking_time_out">2.2.2. Blocking Time-out</a></li>
<li><a href="#callout_timers">2.2.3. Callout Timers</a></li>
</ul>
</li>
<li><a href="#system_tick">2.3. System Tick</a></li>
<li><a href="#memory_allocator">2.4. Memory Allocator</a>
<ul class="sectlevel3">
<li><a href="#how_it_works">2.4.1. How it works</a></li>
<li><a href="#memory_allocator_determinism">2.4.2. Memory Allocator Determinism</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#inter_task_communication">3. <strong><em>Inter-Task Communication</em></strong></a>
<ul class="sectlevel2">
<li><a href="#sleep_wake_events_sleep_queues">3.1. Sleep-Wake Events (Sleep Queues)</a></li>
<li><a href="#direct_signals">3.2. Direct Signals</a>
<ul class="sectlevel4">
<li><a href="#usage_example_supervisor_task_and_asynchronous_signals">3.2.1. Usage Example: Supervisor Task and Asynchronous Signals</a></li>
</ul>
</li>
<li><a href="#semaphores">3.3. Semaphores</a>
<ul class="sectlevel3">
<li><a href="#counting_and_binary_semaphores">3.3.1. Counting and Binary Semaphores</a></li>
<li><a href="#usage_example_task_to_task_bilateral_synchronisation">3.3.2. Usage Example: Task-to-Task Bilateral Synchronisation</a></li>
<li><a href="#mutex_semaphores_locks">3.3.3. Mutex Semaphores (Locks)</a></li>
<li><a href="#usage_example_bounded_buffer">3.3.4. Usage Example: Bounded Buffer</a></li>
<li><a href="#priority_inversion_and_the_priority_inheritance_protocol">3.3.5. Priority Inversion and the Priority Inheritance Protocol</a></li>
</ul>
</li>
<li><a href="#condition_variables">3.4. Condition Variables</a>
<ul class="sectlevel4">
<li><a href="#usage_example_synchronisation_barrier">3.4.1. Usage Example: Synchronisation Barrier</a></li>
<li><a href="#usage_example_readers_writers_lock">3.4.2. Usage Example: Readers Writers Lock</a></li>
</ul>
</li>
<li><a href="#scheduler_lock">3.5. Scheduler Lock</a></li>
<li><a href="#mailbox">3.6. Mailbox</a>
<ul class="sectlevel3">
<li><a href="#usage_example_zero_buffer_channel">3.6.1. Usage Example: <em>Zero-Buffer</em> Channel</a></li>
<li><a href="#example_multi_client_server_synchronous_command_response">3.6.2. Example: Multi-client-server synchronous command-response</a></li>
</ul>
</li>
<li><a href="#signals_as_a_direct_channel">3.7. Signals as a Direct Channel</a></li>
<li><a href="#message_queues">3.8. Message Queues</a>
<ul class="sectlevel3">
<li><a href="#mail_queue">3.8.1. Mail Queue</a>
<ul class="sectlevel4">
<li><a href="#usage_example_asynchronous_zero_copy_message_passing">3.8.1.1. Usage Example: Asynchronous 'Zero-copy' Message Passing</a></li>
<li><a href="#usage_example_work_queue">3.8.1.2. Usage Example: Work Queue</a></li>
</ul>
</li>
<li><a href="#stream_queue">3.8.2. Stream Queue</a>
<ul class="sectlevel4">
<li><a href="#stream_message_size">3.8.2.1. Stream Message-Size</a></li>
<li><a href="#usage_example_averaging_sensor_values">3.8.2.2. Usage Example: Averaging Sensor Values</a></li>
</ul>
</li>
<li><a href="#summing_up_stream_queues_vs_mail_queues">3.8.3. Summing Up: Stream Queues vs Mail Queues</a></li>
</ul>
</li>
<li><a href="#message_passing_ownership">3.9. Message Passing ownership</a>
<ul class="sectlevel3">
<li><a href="#priority_inversion_on_message_passing">3.9.1. Priority Inversion on Message Passing</a></li>
</ul>
</li>
<li><a href="#most_recent_message_protocol_mrm">3.10. Most-Recent Message Protocol (MRM)</a>
<ul class="sectlevel3">
<li><a href="#functional_description">3.10.1. Functional Description</a></li>
<li><a href="#mrm_control_block_configuration">3.10.2. MRM Control Block Configuration</a></li>
<li><a href="#usage_example">3.10.3. Usage Example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#error_handling">4. <em><strong>Error Handling</strong></em></a></li>
<li><a href="#rk0_services_api">5. <em><strong>RK0 Services API</strong></em></a>
<ul class="sectlevel2">
<li><a href="#task_management">5.1. Task Management</a>
<ul class="sectlevel3">
<li><a href="#kcreatetask">5.1.1. kCreateTask</a></li>
<li><a href="#kinit">5.1.2. kInit</a></li>
<li><a href="#kyield">5.1.3. kYield</a></li>
<li><a href="#kschlock">5.1.4. kSchLock</a></li>
<li><a href="#kschunlock">5.1.5. kSchUnlock</a></li>
</ul>
</li>
<li><a href="#signals">5.2. Signals</a>
<ul class="sectlevel3">
<li><a href="#ksignalget">5.2.1. kSignalGet</a></li>
<li><a href="#ksignalset">5.2.2. kSignalSet</a></li>
<li><a href="#ksignalquery">5.2.3. kSignalQuery</a></li>
<li><a href="#ksignalclear">5.2.4. kSignalClear</a></li>
</ul>
</li>
<li><a href="#events_sleep_queues">5.3. Events (Sleep Queues)</a>
<ul class="sectlevel3">
<li><a href="#keventinit">5.3.1. kEventInit</a></li>
<li><a href="#keventsleep">5.3.2. kEventSleep</a></li>
<li><a href="#keventwake">5.3.3. kEventWake</a></li>
<li><a href="#keventsignal">5.3.4. kEventSignal</a></li>
<li><a href="#keventquery">5.3.5. kEventQuery</a></li>
</ul>
</li>
<li><a href="#semaphores_countingbinary">5.4. Semaphores (Counting/Binary)</a>
<ul class="sectlevel3">
<li><a href="#ksemainit">5.4.1. kSemaInit</a></li>
<li><a href="#ksemapend">5.4.2. kSemaPend</a></li>
<li><a href="#ksemapost">5.4.3. kSemaPost</a></li>
<li><a href="#ksemawake">5.4.4. kSemaWake</a></li>
<li><a href="#ksemaquery">5.4.5. kSemaQuery</a></li>
</ul>
</li>
<li><a href="#mutex_semaphore">5.5. Mutex Semaphore</a>
<ul class="sectlevel3">
<li><a href="#kmutexinit">5.5.1. kMutexInit</a></li>
<li><a href="#kmutexlock">5.5.2. kMutexLock</a></li>
<li><a href="#kmutexunlock">5.5.3. kMutexUnlock</a></li>
<li><a href="#kmutexquery">5.5.4. kMutexQuery</a></li>
</ul>
</li>
<li><a href="#condition_variables_2">5.6. Condition Variables</a>
<ul class="sectlevel3">
<li><a href="#kcondvarwait">5.6.1. kCondVarWait</a></li>
<li><a href="#kcondvarsignal">5.6.2. kCondVarSignal</a></li>
<li><a href="#kcondvarbroadcast">5.6.3. kCondVarBroadcast</a></li>
</ul>
</li>
<li><a href="#mailbox_2">5.7. Mailbox</a>
<ul class="sectlevel3">
<li><a href="#kmboxinit">5.7.1. kMboxInit</a></li>
<li><a href="#kmboxsetowner">5.7.2. kMboxSetOwner</a></li>
<li><a href="#kmboxpost">5.7.3. kMboxPost</a></li>
<li><a href="#kmboxpend">5.7.4. kMboxPend</a></li>
<li><a href="#kmboxpeek">5.7.5. kMboxPeek</a></li>
<li><a href="#kmboxquery">5.7.6. kMboxQuery</a></li>
<li><a href="#kmboxpostovw">5.7.7. kMboxPostOvw</a></li>
</ul>
</li>
<li><a href="#mail_queues">5.8. Mail Queues</a>
<ul class="sectlevel3">
<li><a href="#kqueueinit">5.8.1. kQueueInit</a></li>
<li><a href="#kqueuesetowner">5.8.2. kQueueSetOwner</a></li>
<li><a href="#kqueuepost">5.8.3. kQueuePost</a></li>
<li><a href="#kqueuepend">5.8.4. kQueuePend</a></li>
<li><a href="#kqueuepeek">5.8.5. kQueuePeek</a></li>
<li><a href="#kqueuejam">5.8.6. kQueueJam</a></li>
<li><a href="#kqueuequery">5.8.7. kQueueQuery</a></li>
</ul>
</li>
<li><a href="#stream_queue_2">5.9. Stream Queue</a>
<ul class="sectlevel3">
<li><a href="#kstreaminit">5.9.1. kStreamInit</a></li>
<li><a href="#kstreamsetowner">5.9.2. kStreamSetOwner</a></li>
<li><a href="#kstreamsend">5.9.3. kStreamSend</a></li>
<li><a href="#kstreamrecv">5.9.4. kStreamRecv</a></li>
<li><a href="#kstreampeek">5.9.5. kStreamPeek</a></li>
<li><a href="#kstreamjam">5.9.6. kStreamJam</a></li>
<li><a href="#kstreamquery">5.9.7. kStreamQuery</a></li>
</ul>
</li>
<li><a href="#most_recent_message_protocol_mrm_2">5.10. Most-Recent Message Protocol (MRM)</a>
<ul class="sectlevel3">
<li><a href="#kmrminit">5.10.1. kMRMInit</a></li>
<li><a href="#kmrmreserve">5.10.2. kMRMReserve</a></li>
<li><a href="#kmrmpublish">5.10.3. kMRMPublish</a></li>
<li><a href="#kmrmget">5.10.4. kMRMGet</a></li>
<li><a href="#kmrmunget">5.10.5. kMRMUnget</a></li>
</ul>
</li>
<li><a href="#time_application_timers_and_delays">5.11. Time, Application Timers and Delays</a>
<ul class="sectlevel3">
<li><a href="#ktickget">5.11.1. kTickGet</a></li>
<li><a href="#ktimerinit">5.11.2. kTimerInit</a></li>
<li><a href="#ktimercancel">5.11.3. kTimerCancel</a></li>
<li><a href="#ksleep">5.11.4. kSleep</a></li>
<li><a href="#ksleepuntil">5.11.5. kSleepUntil</a></li>
<li><a href="#kbusywait">5.11.6. kBusyWait</a></li>
</ul>
</li>
<li><a href="#memory_pool_allocator">5.12. Memory Pool (Allocator)</a>
<ul class="sectlevel3">
<li><a href="#kmeminit">5.12.1. kMemInit</a></li>
<li><a href="#kmemalloc">5.12.2. kMemAlloc</a></li>
<li><a href="#kmemfree">5.12.3. kMemFree</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#influences">6. Influences</a></li>
</ul>
</div>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<!-- toc disabled -->
</div>
</div>
<div class="sect1 data-line-14">
<h2 id="the_kernel_on_a_glance">1. THE KERNEL ON A GLANCE</h2>
<div class="sectionbody">
<div class="sect2 data-line-17">
<h3 id="the_design_approach">1.1. The design approach</h3>
<div class="exampleblock data-line-19">
<div class="content">
<div class="paragraph data-line-20">
<p><em>RK0 Blog</em>: <a href="https://kernel0.org/2025/05/16/about-processes-tasks-and-threads/">About Processes, Tasks and Threads</a></p>
</div>
</div>
</div>
<div class="paragraph data-line-25">
<p>On the embedded realm, probably because we lack a better abstraction, we use multithreading to fine-tune our load balance and, therefore, responsiveness to achieve real-time.</p>
</div>
<div class="paragraph data-line-27">
<p>This is an arrangement: instead of having a single super-loop, we have many, each running on its own execution stack.</p>
</div>
<div class="paragraph data-line-29">
<p>This arrangement yields an operating system entity to handle—a (logical) <em>Concurrency Unit</em>: in K0, we name it a <em>Task</em> (in RK0  <em><strong>a task is a thread</strong></em>.).</p>
</div>
<div class="sect3 data-line-31">
<h4 id="architecture">1.1.1. Architecture</h4>
<div class="paragraph data-line-33">
<p>If no more details are to be provided, the kernel has a top and a bottom layer. On the top, the Executive manages the resources needed by the application. On the bottom, the Low-level Scheduler works as a software extension of the CPU. Together, they implement the Task abstraction — the Concurrency Unit that enables a multitasking environment.</p>
</div>
<div class="imageblock data-line-36">
<div class="content">
<img src="images/images/layeredkernel.png" alt="layeredkernel" width="50%">
</div>
</div>
<div class="paragraph data-line-39">
<p>In systems design jargon, the Executive enforces policy (what should happen). The Low-level Scheduler provides the mechanism (how it gets done). The services are the primitives that gradually translate policy decisions into concrete actions executed by the Scheduler.
K0&#8217;s goal is determinism on low-end devices. Its multitasking engine operates with no mimics of <em>userland</em>: tasks run on privileged mode, on a different stack pointer from the system stack.</p>
</div>
</div>
<div class="sect3 data-line-43">
<h4 id="suitable_applications">1.1.2. Suitable Applications</h4>
<div class="paragraph data-line-46">
<p>Given the architecture, <em>RK0</em> targets applications with the following characteristics:</p>
</div>
<div class="olist arabic data-line-48">
<ol class="arabic">
<li class="data-line-48">
<p>Are designed to handle particular devices, in which real-time responsiveness is imperative.</p>
</li>
<li class="data-line-49">
<p>Applications and middleware may be implemented on top of appropriate drivers.</p>
</li>
<li class="data-line-50">
<p>Drivers may even include the application itself.</p>
</li>
<li class="data-line-51">
<p><em>Untested programs are not loaded</em>: after the software has been tested it can be assumed reliable.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-54">
<h2 id="core_mechanisms">2. <strong><em>Core Mechanisms</em></strong></h2>
<div class="sectionbody">
<div class="paragraph data-line-56">
<p>This section provides a high-level description of the kernel core mechanisms: scheduler, timers, and memory allocator.</p>
</div>
<div class="sect2 data-line-58">
<h3 id="scheduler">2.1. Scheduler</h3>
<div class="paragraph data-line-61">
<p><em>RK0</em> employs a Rate Monotonic Scheduler. Tasks are assigned priorities accordingly to their request rates - i.e., tasks with shorter periods are assigned to higher priorities. The highest priority is represented by the value '0'; the lowest is represented by the value '31'.</p>
</div>
<div class="paragraph data-line-63">
<p>A scheduler remark is its constant time-complexity (<em>O(1)</em>) and low-latency. This was achieved by careful composing the data structures along with a efficient <em>'choose-next'</em> algorithm. This is detailed below.</p>
</div>
<div class="admonitionblock note data-line-66">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-67">
<p><em>Time-slice</em> was deprecated on version 0.5.0.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect3 data-line-70">
<h4 id="scheduler_data_structures">2.1.1. Scheduler Data Structures</h4>
<div class="sect4 data-line-72">
<h5 id="task_control_block">2.1.1.1. Task Control Block</h5>
<div class="paragraph data-line-74">
<p>Threads are represented as Tasks. Every task is associated to a Task Control Block structure. This is a record for stack, resources and time management. The table below partially represents a Task Control Block (as this document is live, this might not reflect the exact fields of the current version).</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-77">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Task Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Task name</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Saved Stack Pointer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stack Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stack Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Status</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Assigned Priority</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current Priority</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Self-Assigned ID</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Last wake-time</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Run-To-Completion Flag</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Time-out Flag</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">List of owned Mutexes</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aggregated Timeout Node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Aggregated Task List Node</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-95">
<p>Tasks are static - they cannot be created on runtime, to be destroyed, to fork or join.</p>
</div>
<div class="paragraph data-line-97">
<p>In practice, tasks are either <em>RUNNING</em> or '<em>waiting</em>' for their turn to run. Now, we need to clearly define  <em>WAITING</em> and <em>READY</em>.</p>
</div>
<div class="olist arabic data-line-99">
<ol class="arabic">
<li class="data-line-99">
<p>A <em>READY</em> task will be dispatched - therefore, switch to <em>RUNNING</em>, whenever it is the highest priority <em>READY</em> task.</p>
</li>
<li class="data-line-101">
<p>A <em>WAITING</em> task depends on a condition, generalised as an <em>event</em> to switch to <em>READY</em>.</p>
</li>
</ol>
</div>
<div class="imageblock data-line-104">
<div class="content">
<img src="images/images/taskstates.png" alt="taskstates">
</div>
</div>
<div class="paragraph data-line-106">
<p>Logically, the <em>WAITING</em> state will assume different pseudo-states, related to the kind of event that will switch a task to <em>READY</em>:</p>
</div>
<div class="ulist data-line-108">
<ul>
<li class="data-line-108">
<p><em>SLEEPING</em>: a task suspends itself and goes to sleep for a given period; or suspends itself until receiving a <em>wake</em> signal, representing an event.</p>
</li>
<li class="data-line-110">
<p><em>PENDING</em> : the task suspended itself waiting for a combination of signal flags.</p>
</li>
<li class="data-line-112">
<p><em>BLOCKED</em>: A task is blocked on a mutex or semaphore.</p>
</li>
<li class="data-line-114">
<p><em>SENDING/RECEIVING</em>: A producer task when blocking on a Message Passing object switches is status to <em>SENDING</em>. A consumer, to <em>RECEIVING</em>.</p>
</li>
</ul>
</div>
<div class="exampleblock data-line-117">
<div class="content">
<div class="paragraph data-line-118">
<p><strong><em>The scheduler rules, not the heap.</em></strong></p>
</div>
<div class="paragraph data-line-120">
<p><em>RK0</em> tasks are static.</p>
</div>
<div class="paragraph data-line-122">
<p>It’s a design decision rooted in real-time correctness.</p>
</div>
<div class="paragraph data-line-124">
<p>Stacks are defined and passed explicitly when creating a task.</p>
</div>
<div class="paragraph data-line-126">
<p>The wins:</p>
</div>
<div class="ulist data-line-128">
<ul>
<li class="data-line-128">
<p>A memory layout the systems programmer actually knows.</p>
</li>
<li class="data-line-129">
<p>No alignment traps.</p>
</li>
<li class="data-line-130">
<p>Link-time visibility:</p>
<div class="ulist data-line-131">
<ul>
<li class="data-line-131">
<p>Each task’s stack is a named symbol in the linker map.</p>
</li>
<li class="data-line-132">
<p>You can inspect and verify the memory layout before flashing.</p>
</li>
<li class="data-line-133">
<p>A simple <code>objdump</code> reveals all stack allocations — that’s peace of mind.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="imageblock data-line-139">
<div class="content">
<img src="images/images/schdatastruct.png" alt="schdatastruct" width="85%">
</div>
</div>
</div>
<div class="sect4 data-line-141">
<h5 id="task_queues">2.1.1.2. Task Queues</h5>
<div class="paragraph data-line-142">
<p>The backbone of the queues where tasks will wait for their turn to run is a circular doubly linked list: removing any item from a doubly list takes O(1) (provided we don’t need to search the item). As the kernel knows each task’s address, adding and removing is always O(1). Singly linked lists, can’t achieve O(1) for removal in any case.</p>
</div>
</div>
<div class="sect4 data-line-144">
<h5 id="ready_queue_table">2.1.1.3. Ready Queue Table</h5>
<div class="paragraph data-line-146">
<p>Another design choice towards achieving O(1) is the global ready queue, which is a table of FIFO queues—each queue dedicated to a priority—and not a single ordered queue. So, enqueuing a ready task is always O(1). Given the sorting needed, if tasks were placed on a single ready queue, the time complexity would be O(n).</p>
</div>
</div>
<div class="sect4 data-line-148">
<h5 id="waiting_queues">2.1.1.4. Waiting Queues</h5>
<div class="paragraph data-line-150">
<p>The scheduler does not have a unique waiting queue. Every kernel object that has the ability to block a task has an associated waiting queue. Because these  queues are a scheduler component, <em>they follow a priority discipline</em>: the highest priority task is dequeued first, <em>always</em>.</p>
</div>
<div class="paragraph data-line-152">
<p>When an event capable to switch tasks from <em>WAITING</em> to <em>READY</em> happens, one or more tasks (depending on the mechanism) are then placed on the ready list, unique to is priority. Now they are waiting to be picked by the scheduler - that is <em>READY</em> definition.</p>
</div>
</div>
</div>
<div class="sect3 data-line-154">
<h4 id="the_scheduling_algorithm">2.1.2. The scheduling algorithm</h4>
<div class="paragraph data-line-156">
<p>As the ready queue table is indexed by priority - the index 0 points to the queue of ready tasks with priority 0, and so forth, and there are 32 possible priorities - a 32-bit integer can represent the state of the ready queue table. It is a BITMAP:</p>
</div>
<div class="listingblock data-line-158">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">The BITMAP computation: ((1a) OR (1b)) AND (2), s.t.:

(1a) Every Time a task is readied, update: BITMAP |= (1U &lt;&lt; task-&gt;priority );
(1b) Every Time an empty READY QUEUE becomes non-empty, update: BITMAP |= (1U &lt;&lt; queueIndex)
(2): Every Time READY QUEUE becomes empty, update: BITMAP &amp;= ~(1U &lt;&lt; queueIndex);
EXAMPLE:

  Ready Queue Index :     (6)5 4 3 2 1 0
          Not empty :      1 1 1 0 0 1 0
                           -------------&gt;
                 (LOW)  Effective Priority  (HIGH)
In this case, the scenario is a system with 7 priority task levels. Queues with priorities 6, 5, 4, and 1 are not empty.</code></pre>
</div>
</div>
<div class="paragraph data-line-175">
<p>In RK0 source code, the following routines implement the bitmap update:</p>
</div>
<div class="listingblock data-line-177">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* Enqueue a TCB on on the tail of TCB list  */
RK_ERR kTCBQEnq( RK_TCBQ *const kobj, RK_TCB *const tcbPtr)
{
    RK_ERR err = kListAddTail( kobj, &amp;(tcbPtr-&gt;tcbNode));
    if (err == 0)
    {
        /* if a task was enqueued on a list within the ready queue table, update the 'ready bitmap' */
        if (kobj == &amp;readyQueue[tcbPtr-&gt;priority])
        {
            readyQBitMask |= (1 &lt;&lt; tcbPtr-&gt;priority);
        }
    }
    return (err);
}

/* Add a TCB on on the head of TCB list  */
RK_ERR kTCBQJam( RK_TCBQ *const kobj, RK_TCB *const tcbPtr)
{
	RK_ERR err = kListAddHead( kobj, &amp;(tcbPtr-&gt;tcbNode));
	if (err == 0)
	{
		if (kobj == &amp;readyQueue[tcbPtr-&gt;priority])
		{
			readyQBitMask |= (1 &lt;&lt; tcbPtr-&gt;priority);
		}
	}
	return (err);
}

/* Dequeue the head task from a list of TCBs */
RK_ERR kTCBQDeq( RK_TCBQ *const kobj, RK_TCB **const tcbPPtr)
{
    RK_NODE *dequeuedNodePtr = NULL;
    RK_ERR err = kListRemoveHead( kobj, &amp;dequeuedNodePtr);
    if (err != RK_SUCCESS)
    {
        return (err);
    }
    *tcbPPtr = RK_LIST_GET_TCB_NODE( dequeuedNodePtr, RK_TCB);

    RK_TCB *tcbPtr_ = *tcbPPtr;
    RK_PRIO prio_ = tcbPtr_-&gt;priority;

    /* if the list is in the ready queue table and is now empty
     update 'ready bitmap' */
    if ((kobj == &amp;readyQueue[prio_]) &amp;&amp; (kobj-&gt;size == 0))
    {
        readyQBitMask &amp;= ~(1U &lt;&lt; prio_);
    }
    return (err);
}

/* Remove an specific TCB from a TCB List */
RK_ERR kTCBQRem( RK_TCBQ *const kobj, RK_TCB **const tcbPPtr)
{
    RK_NODE *dequeuedNodePtr = &amp;((*tcbPPtr)-&gt;tcbNode);
    RK_ERR err = kListRemove( kobj, dequeuedNodePtr);
    if (err != RK_SUCCESS)
    {
        return (err);
    }
    *tcbPPtr = RK_LIST_GET_TCB_NODE( dequeuedNodePtr, RK_TCB);

    RK_TCB *tcbPtr_ = *tcbPPtr;
    RK_PRIO prio_ = tcbPtr_-&gt;priority;
    if ((kobj == &amp;readyQueue[prio_]) &amp;&amp; (kobj-&gt;size == 0))
    {
          readyQBitMask &amp;= ~(1U &lt;&lt; prio_);
    }
    return (err);
}</code></pre>
</div>
</div>
<div class="paragraph data-line-252">
<p>The Idle Task priority is assigned by the kernel, during initialisation, taking into account all priorities the system programmer has defined. Unless user tasks are occupying all 32 priorities, the Idle Task is treated as an ordinary lowest priority and has a position in the ready queue table. If not, the idle task on practice will have no queue position and will be selected when the BITMAP is 0. In the above bitmap, the idle task is in readyQueue[6].</p>
</div>
<div class="paragraph data-line-254">
<p>Having Ready Queue Table bitmap, we find the highest priority non-empty task list as follows:</p>
</div>
<div class="paragraph data-line-256">
<p>(1) Isolate the <strong>rightmost</strong> '1':</p>
</div>
<div class="listingblock data-line-258">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">RBITMAP = BITMAP &amp; -BITMAP. (- is the bitwise operator for two's complement: ~BITMAP + 1) `</code></pre>
</div>
</div>
<div class="paragraph data-line-262">
<p>In this case:</p>
</div>
<div class="listingblock data-line-264">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">                           [31]       [0]  :  Bit Position
                             0...1110010   :  BITMAP
                             1...0001110   : -BITMAP
                            =============
                             0...0000010   :  RBITMAP
                                     [1]</code></pre>
</div>
</div>
<div class="paragraph data-line-274">
<p><em>The rationale here is that, for a number N, its 2’s complement -N, flips all bits - except the rightmost '1' (by adding '1') . Then, N &amp; -N results in a word with all 0-bits except for the less significant '1'.</em></p>
</div>
<div class="paragraph data-line-276">
<p>(2) Extract the <strong>rightmost '1' <em>position</em></strong>:</p>
</div>
<div class="ulist data-line-278">
<ul>
<li class="data-line-278">
<p>For ARMv7M, we benefit from the <code>CLZ</code> instruction to count the <em>leading zeroes</em>. As they are the the number of zeroes on the left of the rightmost bit '1', this value subtracted from 31 to find the Ready Queue index.</p>
</li>
</ul>
</div>
<div class="listingblock data-line-280">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">__RK_INLINE static inline
unsigned __getReadyPrio(unsigned readyQBitmap)
{
    unsigned ret;
    __ASM volatile (
        "clz    %0, %1     \n"
        "neg    %0, %0     \n"
        "add    %0, %0, #31\n"
        : "=&amp;r" (ret)
        : "r" (readyQBitmap)
        :
    );
    return (ret);
}</code></pre>
</div>
</div>
<div class="paragraph data-line-297">
<p>In the example above, this instruction would return #30, and #31 - #30 = #01.</p>
</div>
<div class="ulist data-line-300">
<ul>
<li class="data-line-300">
<p>For ARMv6M there is no suitable hardware instruction. The algorithm is totally written in C and counts the <em>trailing zeroes</em>, thus, the index number. Although it might vary depending on your compiler settings, it takes ~11 cycles (<em>note it is still O(1)</em>):</p>
</li>
</ul>
</div>
<div class="listingblock data-line-303">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/*
  De Brujin's multiply+LUT
  (Hacker's Delight book)
*/

/* table is on a ram section  for efficiency */
__K_SECTION(getReadyTable)
const static unsigned table[32] =
{
 0, 1, 28, 2, 29, 14, 24, 3, 30, 22, 20, 15, 25, 17, 4, 8,
 31, 27, 13, 23, 21, 19, 16, 7, 26, 12, 18, 6, 11, 5, 10, 9
};

__RK_INLINE static inline
unsigned __getReadyPrio(unsigned readyQBitmap)
{
    unsigned mult = readyQBitmap * 0x077CB531U;

    /* Shift right the top 5 bits
     */
    unsigned idx = (mult &gt;&gt; 27);

    /* LUT */
    unsigned ret = (unsigned)table[idx];
    return (ret);
}</code></pre>
</div>
</div>
<div class="paragraph data-line-332">
<p>For the example above, <code>mult = 0x2 * 0x077CB531 = 0x0EF96A62</code>. The 5 leftmost bits (the index) are <code>00001</code> &#8594; <code>table[1] = 1</code>.</p>
</div>
<div class="paragraph data-line-334">
<p>During a context switch, the procedures to find the highest priority non-empty ready queue table index are as follows:</p>
</div>
<div class="listingblock data-line-336">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">static inline RK_PRIO kCalcNextTaskPrio_(VOID)
{
    if (readyQBitMask == 0U)
    {
        return (idleTaskPrio);
    }
    readyQRightMask = readyQBitMask &amp; -readyQBitMask;
    RK_PRIO prioVal = (RK_PRIO) (__getReadyPrio(readyQRightMask));
    return (prioVal);
}

VOID kSchSwtch(VOID)
{
    /* O(1) complexity */
	nextTaskPrio = kCalcNextTaskPrio_();

	RK_TCB* nextRunPtr = NULL;

	/* O(1) complexity */
	kTCBQDeq(&amp;readyQueue[nextTaskPrio], &amp;nextRunPtr);

	runPtr = nextRunPtr;

}</code></pre>
</div>
</div>
<div class="admonitionblock note data-line-365">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist data-line-366">
<ul>
<li class="data-line-366">
<p><em>RK0</em> is able to handle context-switching with extended frame when a float-point co-processor is available. This must be informed when compiling by defining the symbol <code>__FPU_PRESENT=1</code>.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3 data-line-369">
<h4 id="scheduler_determinism">2.1.3. Scheduler Determinism</h4>
<div class="sect4 data-line-371">
<h5 id="preemptive_scheduling">2.1.3.1. Preemptive Scheduling</h5>
<div class="paragraph data-line-372">
<p>This is a simple test to establish some evidence the scheduler obeys the pre-emption criteria: a higher priority task always pre-empts a lower priority task.</p>
</div>
<div class="paragraph data-line-374">
<p>Task1, 2, 3, 4 are in descending order of priority. If the scheduler is well-behaved, we shall see counters differing by "1".</p>
</div>
<div class="listingblock data-line-376">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">VOID Task1(VOID* args)
{
    RK_UNUSEARGS
	while(1)
	{
		counter1++;
		kPend(RK_WAIT_FOREVER);
	}
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
	while(1)
	{
		counter2++;
		kSignal(task1Handle); /* shall immediately be preempted by task1 */
		kPend(RK_WAIT_FOREVER);    /* suspends again */
	}
}


VOID Task3(VOID* args)
{
    RK_UNUSEARGS
	while(1)
	{
		counter3++;
		kSignal(task2Handle);  /* shall immediately be preempted by task2 */
		kPend(RK_WAIT_FOREVER); /* suspends again */
	}
}

VOID Task4(VOID* args)
{
    RK_UNUSEARGS
	while(1)
	{
	    counter4++;
	    /* shall immediately be preempted by task3 */
	    kSignal(task3Handle); /
	    /* only resumes after all tasks are pending again */
	}
}</code></pre>
</div>
</div>
<div class="paragraph data-line-425">
<p>This is the output after some time running:</p>
</div>
<div class="imageblock data-line-427">
<div class="content">
<img src="images/images/signaldet.png" alt="signaldet">
</div>
</div>
<div class="paragraph data-line-429">
<p>In the above example we have used direct signals. Using semaphores:</p>
</div>
<div class="listingblock data-line-431">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">RK_SEMA sema1;
RK_SEMA sema2;
RK_SEMA sema3;
RK_SEMA sema4;

VOID kApplicationInit(VOID)
{
	kSemaInit(&amp;sema1, RK_SEMA_COUNT, 0);
	kSemaInit(&amp;sema2, RK_SEMA_COUNT, 0);
	kSemaInit(&amp;sema3, RK_SEMA_COUNT, 0);
	kSemaInit(&amp;sema4, RK_SEMA_COUNT, 0);

}

VOID Task1(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		counter1++;
		kSemaWait(&amp;sema1, RK_WAIT_FOREVER);
	}
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		counter2++;
		kSemaSignal(&amp;sema1);
		kSemaWait(&amp;sema2, RK_WAIT_FOREVER);
	}
}

VOID Task3(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		counter3++;
		kSemaSignal(&amp;sema2);
		kSemaWait(&amp;sema3, RK_WAIT_FOREVER);
	}
}

VOID Task4(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{

		counter4++;
		kSemaSignal(&amp;sema3);
	}
}</code></pre>
</div>
</div>
<div class="imageblock data-line-491">
<div class="content">
<img src="images/images/determsema.png" alt="determsema">
</div>
</div>
<div class="paragraph data-line-493">
<p>Here tick is running @ 0.5us</p>
</div>
</div>
<div class="sect4 data-line-495">
<h5 id="cooperative_scheduling">2.1.3.2. Cooperative Scheduling</h5>
<div class="paragraph data-line-497">
<p>If we set all tasks at the same priority and every tasks yields the processor, they will run on a round-robin fashion, one after another. So, every time we pause chances are we will be "somewhere in the middle" of a round.</p>
</div>
<div class="paragraph data-line-499">
<p>If every task increases a counter before yielding what we expect to see is a set of counters on a fashion {K, K, K, K-1, K-1, K-1}. Importantly a counter will not offset another by more than 1 if the scheduler is deterministic.</p>
</div>
<div class="listingblock data-line-501">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* All tasks have the same priority */
VOID Task1(VOID* args)
{
    RK_UNUSEARGS

	while (1)
	{
		count1 += 1;
		kYield();
	}
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		count2 += 1;
		kYield();
	}
}

VOID Task3(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		count3 += 1;
		kYield();
	}
}

VOID Task4(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		count4 += 1;
		kYield();
	}

}

VOID Task5(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		count5 += 1;
		kYield();
	}

}</code></pre>
</div>
</div>
<div class="paragraph data-line-557">
<p>The picture below show the results after ~ 13 million rounds.</p>
</div>
<div class="imageblock data-line-560">
<div class="content">
<img src="images/images/determrr.png" alt="determrr">
</div>
</div>
<div class="admonitionblock tip data-line-564">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-565">
<p>The mindful design choices for data structures and algorithms yielded a core system with highly deterministic behaviour - maintained even under stringent time constraints.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect3 data-line-568">
<h4 id="handling_the_scheduler">2.1.4. Handling the scheduler</h4>
<div class="exampleblock data-line-570">
<div class="content">
<div class="paragraph data-line-571">
<p><em><strong>RK0 Blog:</strong></em>
<a href="https://kernel0.org/2025/06/08/about-real-time-tasks-responsiveness-x-throughput/">About Real-Time, Responsiveness and Throughput</a></p>
</div>
</div>
</div>
<div class="paragraph data-line-576">
<p>An important characteristic of the  scheduler is that it is a <em>preemptive run-to-completion</em> scheduler. This term, '<em>run-to-completion</em>' is often related to strictly cooperative schedulers, in the sense
tasks must <em>yield</em> the processor, otherwise, they monopolise the CPU.</p>
</div>
<div class="paragraph data-line-579">
<p>In <em>RK0</em> tasks with the same priority will run on a First-In-First-Out discipline. This is different from schedulers which employ a <em>time-slice</em>, or a <em>quantum</em> for tasks, so they are forced to yield after a period, and are put at the tail of the <em>Ready Queue</em>.</p>
</div>
<div class="paragraph data-line-581">
<p>This is not the approach in <em>RK0</em>. A task when chosen to be dispatched by the scheduler is expected to run <em>until it yields or wait</em>. This is aligned with real-time demands: the system reacts to stimuli of the environment it is controlling.</p>
</div>
<div class="paragraph data-line-583">
<p>If a task with priority higher than the current running task is dispatched, the running task will be preempted and put back on the head of the ready queue&#8201;&#8212;&#8201;so as soon as it is the highest priority ready task again, it resumes, until it <em>yields</em> or <em>wait</em>.</p>
</div>
<div class="paragraph data-line-585">
<p>This is summarised below:</p>
</div>
<div class="ulist data-line-587">
<ul>
<li class="data-line-587">
<p>The scheduler behaviour is to choose the highest priority READY task to run. Always.</p>
</li>
<li class="data-line-588">
<p>For a set of tasks with the same priority, the schedule works on a First-In-First-Out discipline.</p>
</li>
<li class="data-line-589">
<p>A task must switch to <em>READY</em> state before being eligible for scheduling.</p>
</li>
<li class="data-line-590">
<p>A task will switch from <em>RUNNING</em> to <em>READY</em> if yielding or if being preempted by a higher priority task.</p>
</li>
<li class="data-line-591">
<p>Otherwise it can only go to a <em>WAITING</em> state, and eventually switch back to <em>READY</em>.</p>
</li>
<li class="data-line-592">
<p>When a task is preempted it switches from <em>RUNNING</em> to <em>READY</em> and is placed back on the <em>head</em> position of its Ready Queue. It means that it will be resumed as soon as it is the highest priority ready task again.</p>
</li>
<li class="data-line-593">
<p>On the contrary, if a task <em>yields</em>, it is telling the scheduler that it has completed its cycle. Then, it will be enqueued on the ready queue tail - the last queue position.</p>
</li>
<li class="data-line-594">
<p>When a task <em>waits</em> it is suspended until a condition is satisfied.</p>
</li>
<li class="data-line-595">
<p>When the condition is satisfied, it switches from <em>WAITING</em> to <em>READY</em>, and is enqueued on the tail.</p>
</li>
<li class="data-line-596">
<p>So, tasks with the same priority will <em>round-robin</em> as long as they <em>yield</em> or <em>wait</em>.</p>
</li>
<li class="data-line-597">
<p>If a task never yields or waits, other tasks with the same or lower priority <em>will starve</em>.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-599">
<p>Finally, Tasks with the same priority are <em>initially</em> placed on the <em>Ready Queue</em> associated to that priority, on the order they are <em>created</em>.</p>
</div>
</div>
</div>
<div class="sect2 data-line-601">
<h3 id="timers">2.2. Timers</h3>
<div class="admonitionblock tip data-line-604">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-606">
<p>Context switching is probably the largest overhead on a kernel. The time spent on the System Tick handler contributes to a large portion of this overhead.</p>
</div>
<div class="paragraph data-line-608">
<p>Design Choice:</p>
</div>
<div class="ulist data-line-610">
<ul>
<li class="data-line-610">
<p>Timers are kept on a single list, and only the head element needs to be updated by using a delta-queue approach.</p>
</li>
<li class="data-line-612">
<p>Application Timers that trigger callbacks are run on a deferred run-to-completion system task.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-614">
<p>Benefits:</p>
</div>
<div class="ulist data-line-616">
<ul>
<li class="data-line-616">
<p>Keep the overhead of updating timers as minimal as possible with the delta-queue;</p>
</li>
<li class="data-line-618">
<p>Deferring the Application Timer to a run-to-completion task, meet the requested callback period, while keeping the ability to track system ticks.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<table class="tableblock frame-all grid-all stretch data-line-623">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Timeout Node</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout Type</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Absolute Interval (Ticks)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Relative Interval (Ticks)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting Queue Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Next Timeout Node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Previous Timeout Node</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-633">
<p>Every task is prone to events triggered by timers, which are described in this section. Every Task Control Block has a node to <em>a timeout list</em>.</p>
</div>
<div class="paragraph data-line-635">
<p>This list is a doubly linked list, ordered as a delta list. For instance, three timers (T1,8), (T2,6) and (T3,10) will be ordered as a sequence &lt;(T2,6), (T1,2), (T3,2)&gt; - so it counts &lt;6, (6)+2, ((6)+2)+2&gt;.</p>
</div>
<div class="paragraph data-line-637">
<p>Thus, for every system tick, only the head element on the list needs to be decreased - yielding O(1)  - another design choice towards deterministic behaviour.</p>
</div>
<div class="sect3 data-line-639">
<h4 id="sleep_timers">2.2.1. Sleep Timers</h4>
<div class="ulist data-line-641">
<ul>
<li class="data-line-641">
<p><code>kSleep(ticks)</code>
Suspends the calling task immediatel. When readied, the task will be dispatched once it is the higher priority task, and a will be suspended for the same amount of <code>ticks</code>, no matter how many ticks have elapsed between one activation and another.</p>
</li>
<li class="data-line-644">
<p><code>kSleepUntil(absolute_ticks)</code>
Suspends the calling task and adjusts the sleeping time at <em>every activation</em>, to compensate for time drifts.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-647">
<h4 id="blocking_time_out">2.2.2. Blocking Time-out</h4>
<div class="paragraph data-line-649">
<p>These are timers associated with kernel calls that are blocking. Thus, establishing an upper bound waiting time might benefit them. When the time for unblocking is up, the kernel call returns, indicating a timeout error. When blocking is associated to a kernel object (other than the Task Control Block), the timeout node will store the object waiting queue&#8217;s address, so it can be removed if time expires.</p>
</div>
</div>
<div class="sect3 data-line-651">
<h4 id="callout_timers">2.2.3. Callout Timers</h4>
<table class="tableblock frame-all grid-all stretch data-line-654">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Timer Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Option: Reload/One-Shot</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Phase (Initial Delay)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callout Function Pointer</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Callout Argument</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout Node</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-664">
<p>These are Application Timers that will issue a callback when expiring.
In addition to a callout function, an Application Timer receives an initial phase delay and a period and can choose to run once (one-shot) or auto-reload itself.</p>
</div>
<div class="paragraph data-line-667">
<p>The callback runs within a System Task with priority 0 and is run-to-completion - what makes the scheduler prioritise it over other tasks. Callouts must be made short and unblocking - as they can cause high CPU contention.</p>
</div>
<div class="paragraph data-line-669">
<p>For clarity, Timer Callouts are on a separate list in the kernel, although they share the same <code>TIMEOUT</code> node.</p>
</div>
</div>
</div>
<div class="sect2 data-line-671">
<h3 id="system_tick">2.3. System Tick</h3>
<div class="paragraph data-line-673">
<p>A dedicated peripheral that generates an interrupt after a defined period provides the kernel time reference. For ARMv6/7M, this peripheral is the built-in SysTick, a 24-bit counter timer.
On every tick, the handler performs some housekeeping and assesses the need to call a context switch.</p>
</div>
<div class="paragraph data-line-676">
<p>The "housekeeping" accounts for global timer tracking and any tick-dependent condition that might change a task status.
When a timer expires, it might switch a task from <code>WAITING</code> to <code>READY</code> or dispatch a callback. In the case of a callback, this will also trigger a context-switching for the TimerHandler System Task in which the callback is executed and the related timer(s) are updated properly.</p>
</div>
<div class="paragraph data-line-679">
<p>Note that tasks might switch from <code>WAITING</code> to <code>READY</code> for reasons other than tick-related. In these cases, context switching might be triggered immediately if the readied task can preempt the running task.</p>
</div>
</div>
<div class="sect2 data-line-681">
<h3 id="memory_allocator">2.4. Memory Allocator</h3>
<table class="tableblock frame-all grid-all stretch data-line-684">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Memory Allocator Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Associated Block Pool</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of Blocks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Block Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Number of Free Blocks</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Free Block List</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-693">
<p>Remember that the standard <code>malloc()</code>  leads to fragmentation and (also, because of that) is highly indeterministic. Unless we use it once - to allocate memory before starting up, it doesn’t fit. But often, we need to 'multiplex' memory amongst tasks over time, that is, to dynamically allocate and deallocate.</p>
</div>
<div class="paragraph data-line-695">
<p>To avoid fragmentation, we use fixed-size memory blocks. A simple approach would be a static table marking each block as free or taken. With this pattern, you will need to 'search' for the next available block, if any - the time for searching changes - bounding this search to maximum number of blocks, or <em>O(n)</em>.
To optimise, an approach is to keep track of what is free using a dynamic table—a linked list of addresses. Now we have <em>O(1)</em>.</p>
</div>
<div class="paragraph data-line-698">
<p>We use "meta-data" to initialise the linked list. Every address holds the "next" address value. All addresses are within the range of a pool of fixed-size blocks.
This approach limits the minimal size of a block to the size of a memory address - 32-bit for our supported architecture.</p>
</div>
<div class="paragraph data-line-701">
<p>Yet, this is the cheapest way to store meta-data. If not stored on the empty address itself, an extra 32-bit variable would be needed for each block, so it could have a size that is less than 32-bit.</p>
</div>
<div class="admonitionblock tip data-line-704">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-705">
<p>Allocating memory on run-time is a major source of latency (1), indeterministic (2) behaviour and footprint overhead (3).</p>
</div>
<div class="paragraph data-line-707">
<p>Design choice: the allocator&#8217;s design achieves low-cost, deterministic, fragmentation-free memory management by using fixed-size word-aligned block sizes (1)(2), and embedding metadata within the memory blocks themselves (3).</p>
</div>
<div class="paragraph data-line-709">
<p>Benefits: run-time memory allocation benefits are provided with  no real-time drawbacks.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-713">
<p><em>Importantly, the kernel will always round up the block size to the next multiple of 4. Say the user creates a memory pool, assining blocks to 6-byte wide; they will turn into 8-byte blocks.</em></p>
</div>
<div class="sect3 data-line-715">
<h4 id="how_it_works">2.4.1. How it works</h4>
<div class="paragraph data-line-717">
<p>When a routine calls <code>alloc()</code>, the address to be returned is the one a "free list" is pointing to, say <code>addr1</code>. Before returning <code>addr1</code> to the caller, we update the free list to point to the value stored within <code>addr1</code> - say <code>addr8</code> at that moment.</p>
</div>
<div class="paragraph data-line-719">
<p>When a routine calls <code>free(addr1)</code>, we overwrite whatever has been written in addr1 with the value-free list point to (if no more <code>alloc()</code> were issued, it would still be <code>addr8</code>), and <code>addr1</code> becomes the free list head again.</p>
</div>
<div class="paragraph data-line-721">
<p>Allocating and deallocating fixed-size blocks using this structure and storing meta-data this way is as deterministic (<em>O(1)</em>) and economic as we can get for dynamic memory allocation.</p>
</div>
<div class="paragraph data-line-723">
<p>A drawback is if having a routine writing  non-allocated memory within a pool it will spoil the meta-data and the Allocator will fail.</p>
</div>
</div>
<div class="sect3 data-line-725">
<h4 id="memory_allocator_determinism">2.4.2. Memory Allocator Determinism</h4>
<div class="paragraph data-line-727">
<p>The memory allocator (if well employed) will never fail; it might take the same amount of time to allocate and free a block. In the test below, three tasks with the same priority are allocating, increasing a counter, and freeing a block of <em>128 bytes</em>. If the allocator exhibits deterministic behaviour, these counters might differ by at most 1 whenever we pause the device.</p>
</div>
<div class="exampleblock data-line-729">
<div class="content">
<div class="listingblock data-line-730">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">#include "application.h"

INT stack1[STACKSIZE];
INT stack2[STACKSIZE];
INT stack3[STACKSIZE];

RK_MEM bufPool;
#define BLOCK_SIZE	128
#define	N_BLOCKS	3
BYTE buf[N_BLOCKS][BLOCK_SIZE];


VOID kApplicationInit(VOID)
{
	kMemInit(&amp;bufPool, buf, BLOCK_SIZE, N_BLOCKS);
}

volatile int counter1, counter2, counter3=0;

VOID Task1(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		BYTE* addr = kMemAlloc(&amp;bufPool);
		kassert(addr!=NULL);
		RK_ERR err = kMemFree(&amp;bufPool, addr);
		kassert(err==0);
		counter1++;
		kYield();
	}
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{

		BYTE* addr = kMemAlloc(&amp;bufPool);
		kassert(addr!=NULL);
		RK_ERR err = kMemFree(&amp;bufPool, addr);
		kassert(err==0);
		counter2++;
		kYield();
	}
}

VOID Task3(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{

		BYTE* addr = kMemAlloc(&amp;bufPool);
		kassert(addr!=NULL);
		RK_ERR err = kMemFree(&amp;bufPool, addr);
		kassert(err==0);
		counter3++;
		kYield();
	}

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-798">
<p>Below are the results after ~2.5 million ticks of 0.5 ms.</p>
</div>
<div class="imageblock data-line-800">
<div class="content">
<img src="images/images/determmem.png" alt="determmem" width="75%">
</div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-804">
<h2 id="inter_task_communication">3. <strong><em>Inter-Task Communication</em></strong></h2>
<div class="sectionbody">
<div class="exampleblock data-line-806">
<div class="content">
<div class="paragraph data-line-807">
<p>RK0 Blog:</p>
</div>
<div class="ulist data-line-809">
<ul>
<li class="data-line-809">
<p><a href="https://kernel0.org/2025/01/08/inter-task-communication-on-embedded-operating-systems/">About Inter-Task Communication - Part 1</a></p>
</li>
<li class="data-line-811">
<p><a href="https://kernel0.org/2025/01/09/about-inter-task-communication-p2/">About Inter-Task Communication - Part 2</a></p>
</li>
</ul>
</div>
</div>
</div>
<div class="paragraph data-line-816">
<p>Inter-Task Communication (ITC) refers to the mechanisms that enable tasks to coordinate/cooperate/synchronise by means of sending or receiving information that falls into two logical categories: <em>Signals</em> or <em>Messages</em>.</p>
</div>
<div class="ulist data-line-818">
<ul>
<li class="data-line-818">
<p><strong><em>Signals</em></strong>:
A signal is solely defined by its absence or presence. The meaning is implicit.</p>
</li>
<li class="data-line-821">
<p><strong><em>Messages</em></strong>: When the operations used for tasks to communicate also allow conveying a <em>payload</em>, these mechanisms are regarded as <em>Message Passing</em>.</p>
</li>
</ul>
</div>
<div class="sect2 data-line-824">
<h3 id="sleep_wake_events_sleep_queues">3.1. Sleep-Wake Events (Sleep Queues)</h3>
<table class="tableblock frame-all grid-all stretch data-line-826">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Event Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sleeping Queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout Node</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-832">
<p>The simplest mechanism to handle events are the methods <code>sleep()</code>, <code>wake()</code> and <code>signal()</code> acting on an <code>EVENT</code> kernel object&#8201;&#8212;&#8201;a <em>Sleep Queue</em>.</p>
</div>
<div class="paragraph data-line-834">
<p>The sole purpose of the <code>EVENT</code> kernel object is to have a unique waiting queue associated to an event. <em>There is no other data&#8201;&#8212;&#8201;e.g., one cannot know if the event has ever happened.</em></p>
</div>
<div class="paragraph data-line-836">
<p>Sometimes we cannot, define what happens if a signal is late; so, if a task is not waiting (that is the same as 'ready for the signal') when it is issued, drop it.</p>
</div>
<div class="paragraph data-line-838">
<p>Thus, the operation <code>sleep(&amp;event, timeout)</code>  <em>always</em> put to the caller task to sleep (except if using a timeout=<code>RK_NO_WAIT</code>, the call has no effect).</p>
</div>
<div class="paragraph data-line-840">
<p>A <code>signal(&amp;event)</code> will wake-up a single task - the highest priority.</p>
</div>
<div class="paragraph data-line-842">
<p>A <code>wake(&amp;event, n, &amp;r)</code> is a <em>broadcast</em>: at most <code>n</code> sleeping tasks will switch to <code>READY</code>. This <code>n</code> is a means of providing the programmer a worst-case-time¹. <code>r</code> will store the number of remaining tasks, if any.</p>
</div>
<div class="paragraph data-line-844">
<p>If the programmer is willing to wake <em>ALL</em> tasks, they can either use the <code>flush(&amp;event)</code> helper macro or use <code>n=0</code>.</p>
</div>
<div class="paragraph data-line-847">
<p>If there are no tasks sleeping for an event signal/wake operations will have no effect at all&#8201;&#8212;&#8201;<em>they are lost.</em></p>
</div>
<div class="paragraph data-line-849">
<p>Finally, a <code>query()</code> operation on an Event object will return the number of sleeping tasks.</p>
</div>
<div class="admonitionblock note data-line-853">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-854">
<p>As dequeing tasks from a waiting queue is made on a critical region with global interrupts disabled, doing so with a unknown bound time, makes the operation unpredictable.
<em>But</em>, since tasks are not dynamically created one should be able to predict the worst-case.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2 data-line-859">
<h3 id="direct_signals">3.2. Direct Signals</h3>
<table class="tableblock frame-all grid-all stretch data-line-862">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Within Task Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current Flags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Required Flags</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Options</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note data-line-870">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-871">
<p>This primitive does not mimic POSIX or UNIX/BSD Signals.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-874">
<p>Each Task Control Block stores event notifications other tasks will raise. Often we define that a 32-bit Signal carries 32 <em>signal/event flags</em>&#8201;&#8212;&#8201;it can represent a combination of 32 different events, if defining 1 event/bit. A bit  set means an event is pending to be detected. A detected event is always <em>consumed</em>, that is, the bit is cleared.</p>
</div>
<div class="paragraph data-line-877">
<p>Bitwise friendly, the API is written as <code>set()</code> (as to signal/post), <code>get()</code> (as to wait/pend).</p>
</div>
<div class="paragraph data-line-879">
<p>A task checks for a combination of events it is expecting. This combination can be satisfied if <code>ANY</code> (OR logic) of the required bits are set or if <code>ALL</code> of the required bits are set (AND logic).</p>
</div>
<div class="paragraph data-line-881">
<p>Thus, if the condition is not met the task can optionally suspends, switching to the logical state <code>PENDING</code>.</p>
</div>
<div class="paragraph data-line-883">
<p>When another task issues a <code>set()</code> which result satisfies the waiting condition, the task state is then <code>READY</code>. The <em>matched flags are consumed</em> (cleared).
A <em>set</em> is always an <em>OR</em> operation of an input mask over the current value.</p>
</div>
<div class="paragraph data-line-886">
<p>Others operations are to <code>query</code> a tasks&#8217;s event register, and to <code>clear</code> its own registers.</p>
</div>
<div class="paragraph data-line-888">
<p>One possible usage pattern is a task&#8217;s cycle begins checking for any events (it is able/supposed to handle).</p>
</div>
<div class="sect4 data-line-891">
<h5 id="usage_example_supervisor_task_and_asynchronous_signals">3.2.1. Usage Example: Supervisor Task and Asynchronous Signals</h5>
<div class="paragraph data-line-893">
<p>If using it on a supervisor task&#8201;&#8212;&#8201;it can create a neat event-driven pattern for a soft/firm real-time system.</p>
</div>
<div class="listingblock data-line-895">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">VOID SupervisorTask(VOID *args)
{
    RK_UNUSEARGS

    ULONG gotFlags = 0UL;

    while(1)
    {
        /*  range: 0x01-0xFFFF, any bit. store in gotFlags. do not block.*/
        RK_ERR err = kSignalGet(0xFFFF, RK_FLAGS_ANY, &amp;gotFlags, RK_NO_WAIT);
        if (err == RK_SUCCESS)
        {

            if (gotFlags &amp; PENDING_AIRFLOW_INCREASE):
            {    /* notify actuator's task with the proper signal */
                   kSignalSet(airFlowTaskHandle, AIRFLOW_INCREASE_SIGNAL);
            }
                /* others... */


        }

        kSleepUntil(SUPERVISOR_T_PERIOD);
    }

}</code></pre>
</div>
</div>
<div class="paragraph data-line-926">
<p>Task Signals are the the only ITC primitive that cannot be disabled.</p>
</div>
<div class="paragraph data-line-928">
<p><code>0x00</code> is invalid for both <code>set()</code> and <code>get()</code> operations.</p>
</div>
<div class="admonitionblock note data-line-932">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-933">
<p>Every blocking call issued with the option <code>RK_NO_WAIT</code> will be a <code>try</code> operation - if a condition is not satisfied it immediately returns an error code, and the caller is not blocked.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2 data-line-936">
<h3 id="semaphores">3.3. Semaphores</h3>
<table class="tableblock frame-all grid-all stretch data-line-938">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Semaphore Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Counter (Unsigned Integer)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Semaphore Type (Counter/Binary)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting Queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout Node</p></td>
</tr>
</tbody>
</table>
<div class="exampleblock data-line-946">
<div class="content">
<div class="paragraph data-line-947">
<p>A semaphore S is a nonnegative integer variable, apart from the operations it is subjected to. S is initialized to a nonnegative value. The two operations, called P and V, are defined as follows:</p>
</div>
<div class="paragraph data-line-949">
<p><code>P(S): if S &gt; 0 then S := S-1, else the process is suspended until S &gt; 0.</code></p>
</div>
<div class="paragraph data-line-951">
<p><code>V(S): if there are processes waiting, then one of them is resumed; else S := S+1.</code></p>
</div>
<div class="paragraph data-line-953">
<p>(Dijkstra, 1968)</p>
</div>
</div>
</div>
<div class="paragraph data-line-957">
<p><em>Semaphores</em> are <em>public</em> kernel objects for signalling and waiting for events. Effectively they are <em>event counters</em>. Tasks cooperate over a public semaphore by signalling and waiting for events. In RK0 a semaphore&#8217;s counter is unsigned.</p>
</div>
<div class="paragraph data-line-959">
<p>The primitives <code>post()</code> is the <code>V(S)</code>, and <code>pend()</code> is the <code>P(S)</code> as described above.</p>
</div>
<div class="paragraph data-line-961">
<p>When <code>pend()</code> is issued on a semaphore which counter is 0, the caller (optionally) switches to a <em>BLOCKED</em> state, and is enqueued within the semaphore queue.</p>
</div>
<div class="paragraph data-line-963">
<p>After that, every <code>post()</code> issued to a semaphore releases a single task, ordered by priority, until there is no more blocked tasks within the semaphore.</p>
</div>
<div class="paragraph data-line-965">
<p>Then, the internal counter will increase above 0, only and if only there are no tasks on the waiting queue when the semaphore is signalled.</p>
</div>
<div class="sect3 data-line-968">
<h4 id="counting_and_binary_semaphores">3.3.1. Counting and Binary Semaphores</h4>
<div class="paragraph data-line-971">
<p>A <em>Counting Semaphore</em> is the original semaphore as introduced by Dijkstra in the late 60&#8217;s.
It counts up to <code>N</code>, limited by the maximum number defined on <code>RK_SEMA_MAX_VALUE</code> (default is 255).</p>
</div>
<div class="paragraph data-line-974">
<p>The typical use case for <em>Counting Semaphores</em> is as a "credit tracker"&#8201;&#8212;&#8201;one uses it to verify (wait/pend) and indicate (signal/post) the availability of a countable resource&#8201;&#8212;&#8201;say, number of slots within a queue.</p>
</div>
<div class="paragraph data-line-976">
<p>A <em>Binary Semaphore</em> is a specialisation: it counts up to 1 and down to 0&#8201;&#8212;&#8201;they do not accumulate. We often say its <em>either FULL or EMPTY</em>. The typical use case is for task-to-task (unilateral or bi-lateral), or ISR-to-task (unilateral) synchronisation.</p>
</div>
<div class="paragraph data-line-978">
<p>In this sense, they overlap the <em>Direct Signals</em> mechanism, that can be seen as a pack of <em>private binary semaphores</em> (only the task itself can <code>pend</code> but any task can <code>post</code>). They can also be used as <em>Locks</em> for mutual-exclusion, but it has drawbacks as will be explained later.</p>
</div>
<div class="paragraph data-line-980">
<p>Semaphores can also <em>broadcast a signal</em>, on the same way as described for <code>EVENTS</code>, either by <code>wake(n)</code> or <code>flush()</code>.</p>
</div>
<div class="paragraph data-line-983">
<p>Finally, a <code>query()</code> operation on a semaphore will return the number of waiting tasks if any, or the counter value. To differentiate, the number of waiting tasks is returned as a negative value. A nonnegative value is the semaphore&#8217;s counter value.</p>
</div>
<div class="paragraph data-line-985">
<p>Notes:</p>
</div>
<div class="olist arabic data-line-987">
<ol class="arabic">
<li class="data-line-987">
<p>The <code>post</code> and <code>pend</code> operations are aliased to <code>signal()</code> and <code>wait()</code> respectively, to satisfy those who prefer this nomenclature.</p>
</li>
<li class="data-line-988">
<p>If Binary Semaphore is initialised with a value &gt; 1, the effective value is 1.</p>
</li>
</ol>
</div>
</div>
<div class="sect3 data-line-991">
<h4 id="usage_example_task_to_task_bilateral_synchronisation">3.3.2. Usage Example: Task-to-Task Bilateral Synchronisation</h4>
<div class="paragraph data-line-993">
<p>The snippet below shows two tasks lock-stepping by posting and pending on (binary) semaphores.
Task2 depends on Task1 finishing 'work1' to perform 'work2'. And vice-versa.</p>
</div>
<div class="exampleblock data-line-996">
<div class="content">
<div class="paragraph data-line-998">
<p>(Note Direct Signals are a better choice for this use-case.)</p>
</div>
<div class="listingblock data-line-1001">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">RK_SEMA work1Sema;
RK_SEMA work2Sema;

VOID kApplicationInit(VOID)
{
/* semaphores init at 0 */
	kSemaInit(&amp;work1Sema, RK_SEMA_BIN, 0);
	kSemaInit(&amp;work2Sema, RK_SEMA_BIN, 0);

}

VOID Task1(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
	    doWork1();
		kSemaPost(&amp;work1Sema);
		kSemaPend(&amp;work2Sema, RK_WAIT_FOREVER);
		 /* T1 finished. Waiting for T2. */

	}
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
	while (1)
	{
		 kSemaPend(&amp;work1Sema, RK_WAIT_FOREVER);
		 doWork2();
		 kSemaPost(&amp;work2Sema);
	}
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3 data-line-1042">
<h4 id="mutex_semaphores_locks">3.3.3. Mutex Semaphores (Locks)</h4>
<table class="tableblock frame-all grid-all stretch data-line-1045">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mutex Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Locked State (Boolean)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting Queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Timeout Node</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mutex Node (list node within the owner TCB)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-1055">
<p>Some code regions are critical in that they cannot be accessed by more than one task at once. Acquiring (<code>lock()</code>) a mutex before entering a region and releasing it when leaving makes that region mutually exclusive.</p>
</div>
<div class="paragraph data-line-1057">
<p>A Mutex is another semaphore specialisation&#8201;&#8212;&#8201;it can be seen as a binary semaphore with a notion of ownership - when a task susccesfully acquires a mutex is now the <em>owner</em>, and only this task can release it.</p>
</div>
<div class="paragraph data-line-1059">
<p>If a task tries to acquire an already locked mutex, it switches to <code>BLOCKED</code> state until <em>the mutex is unlocked by its owner</em>. Then, the highest priority task waiting to acquire the resource is dequeued, as on semaphores.</p>
</div>
<div class="paragraph data-line-1061">
<p>However, unlike semaphores, the complementary operation, <code>unlock()</code>, when issued by a non-owner, has undefined behaviour. In K0, it will be a hard fault.</p>
</div>
<div class="paragraph data-line-1063">
<p>Mutexes are solely for mutual exclusion; they cannot be used for signalling. It is common to use Counting Semaphores initialised as 1, or Binary Semaphores for mutual exclusion.</p>
</div>
<div class="paragraph data-line-1065">
<p>However, particularly for a Counting Semaphore, if the count increases twice in a row, the mutual exclusion is gone. For both, <em>Priority Inversion</em> can become a problem, as will be explained.</p>
</div>
</div>
<div class="sect3 data-line-1070">
<h4 id="usage_example_bounded_buffer">3.3.4. Usage Example: Bounded Buffer</h4>
<div class="paragraph data-line-1072">
<p>The snippet below shows a <em>consumer-producer</em> pattern for a buffer with K slots (<em>bounded buffer pattern</em>). Two semaphores track the number of slots for the producer and items for the consumer. The mutex prevents any write or read from being disrupted.</p>
</div>
<div class="exampleblock data-line-1074">
<div class="content">
<div class="listingblock data-line-1076">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">RK_SEMA  item;
RK_SEMA  space;
RK_MUTEX lock;
#define N (K) /*some K&gt;1*/
typedef struct mesg
{
 UINT field1;
 UINT field2;
 UINT field3;
 UINT field4;
} Mesg_t; /* a 16-byte message */

/* a ring buffer of messages */
Mesg_t mailbox[N]={0};

kApplicationInit(VOID)
{
    kSemaInit(&amp;item,  RK_SEMA_COUNT, 0); /* no items */
    kSemaInit(&amp;space, RK_SEMA_COUNT, N); /* N buffers available */
    kMutexInit(&amp;lock);
}
/* circular buffer handling omitted */

/* wait for space, lock, write, unlock, signal there is item */
VOID PostMail(Mesg_t* sendPtr)
{
    kSemaWait(&amp;space, RK_WAIT_FOREVER);
    kMutexLock(&amp;lock,  RK_WAIT_FOREVER);
    memcpy(&amp;mailbox[tail], sendPtr, sizeof(Mesg_t));
    kMutexUnlock(&amp;lock);
    kSemaSignal(&amp;item);
}

/* wait for item, lock, read, unlock, signal there is space */
VOID PendMail(Mesg_t* recvPtr)
{
    kSemaWait(&amp;item, RK_WAIT_FOREVER);
    kMutexLock(&amp;lock,  RK_WAIT_FOREVER);
    memcpy(recvPtr, &amp;mailbox[head], sizeof(Mesg_t));
    kMutexUnlock(&amp;lock);
    kSemaSignal(&amp;space);
}</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note data-line-1123">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-1124">
<p><code>pend()</code>/<code>lock()</code>  when issued with the option <code>RK_NO_WAIT</code> will immediately return if the task cannot acquire the semaphore/mutex&#8201;&#8212;&#8201;the task will not be blocked.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
</div>
<div class="sect3 data-line-1130">
<h4 id="priority_inversion_and_the_priority_inheritance_protocol">3.3.5. Priority Inversion and the Priority Inheritance Protocol</h4>
<div class="paragraph data-line-1133">
<p>Let TH, TM, and TL be three tasks with priority high (H), medium (M) and low (L), respectively. Say TH is dispatched and blocks on a mutex that 'TL' has acquired (i.e.: <em>"TL is blocking TH</em>").</p>
</div>
<div class="paragraph data-line-1135">
<p>If 'TM' does not need the resource, it will run and preempt 'TL'. And, by transition, TH.</p>
</div>
<div class="paragraph data-line-1137">
<p>From now on, 'TH' has an <em>unbounded waiting time</em> because any task with priority higher than 'L' that does not need the resource indirectly prevents it from being unblocked&#8201;&#8212;&#8201;<em>awful.</em></p>
</div>
<div class="paragraph data-line-1139">
<p>Mutexes in RK0 can implement a protocol called priority inheritance.</p>
</div>
<div class="paragraph data-line-1141">
<p>This protocol is characterised by this invariant, simply put:</p>
</div>
<div class="exampleblock data-line-1143">
<div class="content">
<div class="paragraph data-line-1144">
<p><strong><em>At any instant a Task assumes the highest priority amongst the tasks it is blocking</em></strong>.</p>
</div>
</div>
</div>
<div class="paragraph data-line-1147">
<p>If employed on the situation described above, task TM cannot preempt TL, whose effective priority would have been raised to 'H'. (The <em>nominal priority</em> is the priority assigned to task when it is created, the <em>effective priority</em> is the value assumed when the protocol is applied.)</p>
</div>
<div class="paragraph data-line-1149">
<p>It is straightforward to reason about this when you consider the scenario of a single mutex.</p>
</div>
<div class="paragraph data-line-1151">
<p>But when locks nest&#8201;&#8212;&#8201;that is, more than one critical region&#8201;&#8212;&#8201;the protocol also needs to be:</p>
</div>
<div class="ulist data-line-1153">
<ul>
<li class="data-line-1153">
<p>Transitive: that is, if T1 is blocking T2, and T2 is blocking T3, if T3 has the highest priority, T3 propagates its priority to T1 via T2.</p>
</li>
<li class="data-line-1155">
<p>A task can own several mutexes at once. Thus, when exiting the critical region it needs to look up each waiting queue, and assume the highest priority. If there are no blocked tasks behind, its nominal priority is then restored. (As tasks are enqueued by priority, it means looking at the task waiting on the head of each waiting queue.)</p>
</li>
</ul>
</div>
<div class="paragraph data-line-1157">
<p>Below a demonstration:</p>
</div>
<div class="exampleblock data-line-1158">
<div class="content">
<div class="listingblock data-line-1159">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* Task1 has the Highest nominal priority */
/* Task2 has the Medium nominal priority */
/* Task3 has Lowest nominal priority */

/* Note Task3 starts as 1 and 2 are delayed */

K_DECLARE_TASK(task1Handle, Task1, stack1, STACKSIZE)
K_DECLARE_TASK(task2Handle, Task2, stack2, STACKSIZE)
K_DECLARE_TASK(task3Handle, Task3, stack3, STACKSIZE)


RK_MUTEX mutexA;
RK_MUTEX mutexB;

VOID kApplicationInit(VOID)
{
	kassert(!kCreateTask(&amp;task1Handle, Task1, RK_NO_ARGS, "Task1", stack1, \
		STACKSIZE, 1, RK_PREEMPT));
	kassert(!kCreateTask(&amp;task2Handle, Task2, RK_NO_ARGS, "Task2", stack2, \
		STACKSIZE, 2, RK_PREEMPT));
	kassert(!kCreateTask(&amp;task3Handle, Task3, RK_NO_ARGS, "Task3", stack3, \
		STACKSIZE, 3, RK_PREEMPT));

/* mutexes initialised with priority inheritance enabled */
	kMutexInit(&amp;mutexA, RK_INHERIT);
	kMutexInit(&amp;mutexB, RK_INHERIT);
}



VOID Task3(VOID *args)
{
	RK_UNUSEARGS
	while (1)
	{
		printf("@ %lums: [TL] Attempting to LOCK 'A' | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kMutexLock(&amp;mutexA, RK_WAIT_FOREVER);

		printf("@ %lums: [TL] LOCKED 'A' (in CS) | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kBusyWait(60); /* &lt;-- important */

		printf("@%lums: [TL] About to UNLOCK 'A' | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kMutexUnlock(&amp;mutexA);

		printf("---&gt;");
		printf("@%lums: [TL] Exit CS | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kSleep(4);
	}
}

VOID Task2(VOID *args)
{
	RK_UNUSEARGS
	while (1)
	{
		kSleep(5);

		printf("@%lums: [TM] Attempting to LOCK 'B' | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);
		kMutexLock(&amp;mutexB, RK_WAIT_FOREVER);

		printf("@%lums: [TM] LOCKED 'B', now trying to LOCK 'A' | Eff: %d | Nom: %d\r\n",
			   kTickGet(), runPtr-&gt;priority, runPtr-&gt;prioReal);
		kMutexLock(&amp;mutexA, RK_WAIT_FOREVER);

		printf("@%lums: [TM] LOCKED 'A' (in CS) | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);
		kMutexUnlock(&amp;mutexA);

		printf("@%lums: [TM] UNLOCKING 'B' | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kMutexUnlock(&amp;mutexB);

		printf("---&gt;");

		printf("@%lums: [TM] Exit CS | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);
	}
}

VOID Task1(VOID *args)
{
	RK_UNUSEARGS
	while (1)
	{
		kSleep(2);

		printf("@%lums: [TH] Attempting to LOCK 'B'| Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kMutexLock(&amp;mutexB, RK_WAIT_FOREVER);

		printf("@%lums: [TH] LOCKED 'B' (in CS)  | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);

		kMutexUnlock(&amp;mutexB);

		printf("---&gt;");

		printf("@%lums: [TH] Exit CS | Eff: %d | Nom: %d\r\n", kTickGet(),
			   runPtr-&gt;priority, runPtr-&gt;prioReal);
	}
}</code></pre>
</div>
</div>
<div class="imageblock data-line-1276">
<div class="content">
<img src="https://kernel0org.wordpress.com/wp-content/uploads/2025/06/prioinh-1.png" alt="prioinh 1">
</div>
</div>
<div class="paragraph data-line-1279">
<p>In the image above you can see on the left that tasks are running interleaving medium, higher and low priorities. The PI protocol is acting: you can see on the green dots, a lower priority task leaves the critical section with a higher effective priority, since it has blocked a higher priority task.</p>
</div>
<div class="paragraph data-line-1281">
<p>Furthermore, the nested critical sections always finish on the order H&#8594;M&#8594;L. This means that although we enforced some priority inversion, the higher priority tasks have finished earlier than the lower ones. <em>The mechanism is working</em>.</p>
</div>
<div class="paragraph data-line-1283">
<p>Importantly, we can say that <em>the time for nested locks is bounded to the maximum time a lower priority task will be within a critical region</em>. You can see that on the picture by looking at the red and yellow dots. The time elapsed is the 60ms the lowest priority tasks uses on the busy-wait call.</p>
</div>
</div>
</div>
<hr>
<div class="paragraph data-line-1292">
<p><em>Mutexes in RK0 are not recursive</em>; because <em>recursive</em> is not a property of Mutexes in RK0 that are not <em>recursive</em>.</p>
</div>
<div class="paragraph data-line-1295">
<p>That said,</p>
</div>
<div class="admonitionblock note data-line-1299">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A locked mutex which owner tries to lock more than once will result on a hard fault.
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-1301">
<p>This way, the kernel prevents the madness of reentrant calls on critical sections.</p>
</div>
<div class="exampleblock data-line-1303">
<div class="content">
<div class="paragraph data-line-1304">
<p><em><strong>Mutexes vs Binary Semaphores</strong></em></p>
</div>
<div class="paragraph data-line-1306">
<p>There is (or used to be) a lot of fuss about whether binary semaphores are appropriate to use as locks. As a practical guideline: if all tasks sharing the resource have the same priority, the use of a binary semaphore <em>can be appropriate</em>&#8201;&#8212;&#8201;because a binary semaphore is considerably faster. It all depends on the case.</p>
</div>
<div class="paragraph data-line-1308">
<p>The drawback is the lack of ownership: any task can accidentally release the resource. On a large codebase, this can become a real problem. Nonetheless, this is a problem for semaphores in general.</p>
</div>
<div class="paragraph data-line-1310">
<p>For tasks with different priorities, binary semaphores should never be considered for mutual exclusion, unless priority inversion is not problem (how?).</p>
</div>
<div class="paragraph data-line-1312">
<p>Counting semaphores initialised as 1 are too risky. Besides the priority inversion, if the count ever increases above 1, mutual exclusion is lost and multiple tasks can enter the critical section at once.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-1316">
<h3 id="condition_variables">3.4. Condition Variables</h3>
<div class="paragraph data-line-1319">
<p>The <code>EVENT</code> object is a <em>Condition Variable</em> as devised by Hoare. In <em>RK0</em> you can use them along with Mutexes, following the same semantics for <em>Pthreads Condition Variables</em>.</p>
</div>
<div class="paragraph data-line-1321">
<p>CVs are one of the most common means to create <em>Monitor</em>-like constructs: higher-level synchronisation mechanisms&#8201;&#8212;&#8201;so the synchronisation details are encapsulated on an ADT (a data structure plus the operations acting on it).</p>
</div>
<div class="paragraph data-line-1323">
<p>Whenever a task needs to test for a condition before proceeding, it locks a mutex to test the condition within a critical region. If the condition evaluates true, it proceeds and unlock the mutex at the end:</p>
</div>
<div class="listingblock data-line-1325">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* A possible pattern */

RK_EVENT condVar;
RK_MUTEX guardMutex;

/* entering the critical region */

lock(&amp;guardMutex);

while (!condition)
{
    /* these 2 operation must be atomic*/
    unlock(&amp;guardMutex);
    sleep(&amp;condVar);
    /* another task signals/broadcast when the condition is valid */
    /* wake here, lock the mutex, test again */
    lock(&amp;guardMutex);
}
/* proceed */
/* exit critical region */

unlock(&amp;guardMutex)

return;</code></pre>
</div>
</div>
<div class="paragraph data-line-1354">
<p>If the condition is evaluated as false, the task goes to sleep - to wait for a wake signal when the condition is true. The detail is that it goes to sleep and unlocks the mutex all in an atomic operation. When task is awaken it locks the mutex again.</p>
</div>
<div class="paragraph data-line-1356">
<p>The API provides helpers: <code>kCondVarWait(&amp;event, &amp;mutex, timeout)</code>, <code>kCondVarSignal(&amp;event)</code> and <code>kCondVarBroadcast(&amp;event)</code>. The <code>kCondVarWait</code> is the really helpful one as it provides the atomicity needed. If not atomic, the <code>unlock()</code> might cause a context switch before the running task can goes to sleep, and nothing works.</p>
</div>
<div class="paragraph data-line-1358">
<p><code>broadcast()</code> and <code>signal()</code> are just aliases for <code>flush</code> and <code>signal</code> on a <code>EVENT</code>, respectively.</p>
</div>
<div class="paragraph data-line-1361">
<p><em>Condition Variables</em> are often used to create <em>Monitor-like</em> synchronisation primitives. A <em>Monitor</em> is an ADT that hides the synchronisation details on the operations.</p>
</div>
<div class="sect4 data-line-1364">
<h5 id="usage_example_synchronisation_barrier">3.4.1. Usage Example: Synchronisation Barrier</h5>
<div class="paragraph data-line-1366">
<p>A given number of tasks must reach a point in the program before <em>all can proceed</em> - so, every task call a <code>barrWait(&amp;barrier, numberOfTasks)</code> to catch-up with the set of tasks it must synchronise.</p>
</div>
<div class="paragraph data-line-1368">
<p>The last task entering the barrier will broadcast a signal to all tasks that are waiting for the wake condition.</p>
</div>
<div class="paragraph data-line-1370">
<p>Note that the mutex enforces a single active task within the barrier. They enter and leave on a <em>'turnstile'</em>.</p>
</div>
<div class="exampleblock data-line-1372">
<div class="content">
<div class="listingblock data-line-1373">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* Synchronisation Barrier */

typedef struct
{
    RK_MUTEX lock;
    RK_EVENT event;
    UINT count;        /* number of tasks in the barrier */
    UINT round;        /* increased every time all tasks synch     */
} Barrier_t;

VOID BarrierInit(Barrier_t *const barPtr)
{
    kMutexInit(&amp;barPtr-&gt;lock, RK_INHERIT);
    kEventInit(&amp;barPtr-&gt;event);
    barPtr-&gt;count = 0;
    barPtr-&gt;round = 0;
}

VOID BarrierWait(Barrier_t *const barPtr, UINT const nTasks)
{
    UINT myRound = 0;
    kMutexLock(&amp;barPtr-&gt;lock, RK_WAIT_FOREVER);

    /* save round number */
    myRound = barPtr-&gt;round;
    /* increase count on this round */
    barPtr-&gt;count++;

    if (barPtr-&gt;count == nTasks)
    {
        /* reset counter, inc round, broadcast to sleeping tasks */
        barPtr-&gt;round++;
        barPtr-&gt;count = 0;
        kCondVarBroadcast(&amp;barPtr-&gt;event);
    }
    else
    {
        /* a proper wake signal might happen after inc round */
        while ((UINT)(barPtr-&gt;round - myRound) == 0U)
        {
            kCondVarWait(&amp;barPtr-&gt;event, &amp;barPtr-&gt;lock, RK_WAIT_FOREVER);
        }
    }

    kMutexUnlock(&amp;barPtr-&gt;lock);

}


#define N_BARR_TASKS 3

Barrier_t syncBarrier;

VOID kApplicationInit(VOID)
{

    kassert(!kCreateTask(&amp;task1Handle, Task1, RK_NO_ARGS, "Task1", stack1, STACKSIZE, 2, RK_PREEMPT));
    kassert(!kCreateTask(&amp;task2Handle, Task2, RK_NO_ARGS, "Task2", stack2, STACKSIZE, 3, RK_PREEMPT));
    kassert(!kCreateTask(&amp;task3Handle, Task3, RK_NO_ARGS, "Task3", stack3, STACKSIZE, 1, RK_PREEMPT));
	BarrierInit(&amp;syncBarrier);
}
VOID Task1(VOID* args)
{
    RK_UNUSEARGS
    while (1)
    {
        kPuts("Task 1 is waiting at the barrier...\r\n");
        BarrierWait(&amp;syncBarrier, N_BARR_TASKS);
        kPuts("Task 1 passed the barrier!\r\n");
		kSleep(8);

    }
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
    while (1)
    {
        kPuts("Task 2 is waiting at the barrier...\r\n");
        BarrierWait(&amp;syncBarrier, N_BARR_TASKS);
        kPuts("Task 2 passed the barrier!\r\n");
		kSleep(5);
	}
}

VOID Task3(VOID* args)
{
    RK_UNUSEARGS
    while (1)
    {
        kPuts("Task 3 is waiting at the barrier...\r\n");
        BarrierWait(&amp;syncBarrier, N_BARR_TASKS);
        kPuts("Task 3 passed the barrier!\r\n");
        kSleep(3);
	}
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1476">
<p><span class="image"><img src="https://kernel0org.wordpress.com/wp-content/uploads/2025/06/syncbarr.png" alt="syncbarr" width="40%"></span></p>
</div>
</div>
</div>
</div>
<div class="sect4 data-line-1481">
<h5 id="usage_example_readers_writers_lock">3.4.2. Usage Example: Readers Writers Lock</h5>
<div class="paragraph data-line-1483">
<p>Several readers and writers share a piece of memory. Readers can concurrently access the memory to read; a single writer is allowed (otherwise data would be corrupted).</p>
</div>
<div class="paragraph data-line-1485">
<p>When a writer finishes, it checks for any readers waiting. If there is, the writer flushes the readers waiting queue. If not it wakes a single writer, if any.
When the last reader finishes, it signals a writer.</p>
</div>
<div class="paragraph data-line-1488">
<p>Every read or write operation begins with an acquire and finishes with a release.</p>
</div>
<div class="exampleblock data-line-1491">
<div class="content">
<div class="listingblock data-line-1492">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* For condition variables, a best-practice waiting pattern is:

(Mesa) Monitor pattern:

while(!cond)
{
    kCondVarWait(&amp;cv, &amp;mutex);
}

*/

/* a single writer is allowed, if there are no readers */
/* several readers are allowed, if there is no writer*/
typedef struct
{
	RK_MUTEX	 lock;
	RK_EVENT	 writersGo;
	RK_EVENT	 readersGo;
	INT			 rwCount; /* number of active readers if &gt; 0 */
						  /* active writer if -1             */
}RwLock_t;

VOID RwLockInit(RwLock_t *const rwLockPtr)
{

	kMutexInit(&amp;rwLockPtr-&gt;lock, RK_INHERIT);
	kEventInit(&amp;rwLockPtr-&gt;writersGo);
	kEventInit(&amp;rwLockPtr-&gt;readersGo);
	rwLockPtr-&gt;rwCount = 0;
}

/* A writer can acquire if  rwCount = 0 */
/* An active writer is indicated by rwCount = -1; */
VOID RwLockAcquireWrite(RwLock_t *const rwLockPtr)
{
	kMutexLock(&amp;rwLockPtr-&gt;lock, RK_WAIT_FOREVER);
	/* if different than 0, there are either writers or readers */
	/* sleep to be signalled */
	while (rwLockPtr-&gt;rwCount != 0)
	{
	    kCondVarWait(&amp;rwLockPtr-&gt;writersGo, &amp;rwLockPtr-&gt;lock, RK_WAIT_FOREVER);
	    /* mutex is locked when waking up*/
	}
	/* woke here, set an active writer */
	rwLockPtr-&gt;rwCount = -1;
	kMutexUnlock(&amp;rwLockPtr-&gt;lock);
}

/* a writer releases waking up all waiting readers, if any */
/* if there is no readers, a writer can get in */
VOID RwLockReleaseWrite(RwLock_t *const rwLockPtr)
{
	kMutexLock(&amp;rwLockPtr-&gt;lock, RK_WAIT_FOREVER);

	rwLockPtr-&gt;rwCount = 0; /* indicate no writers*/

	/* if there are waiting readers, flush */
	ULONG nWaitingReaders=0;
	kEventQuery(&amp;rwLockPtr-&gt;readersGo, &amp;nWaitingReaders);
	if (nWaitingReaders &gt; 0)
	{
	    /* condVarBroadcast is just an alias for an event flush */
		kEventFlush(&amp;rwLockPtr-&gt;readersGo);
	}
	else
	{
		/* wake up a single writer if any */
		kEventSignal(&amp;rwLockPtr-&gt;writersGo);
	}
	kMutexUnlock(&amp;rwLockPtr-&gt;lock);
}

/* a reader can acquire if there are no writers */
VOID RwLockAcquireRead(RwLock_t *const rwLockPtr)
{
	kMutexLock(&amp;rwLockPtr-&gt;lock, RK_WAIT_FOREVER);
	/* if there is an active writer, sleep */
	while (rwLockPtr-&gt;rwCount &lt; 0)
	{
	    kCondVarWait(&amp;rwLockPtr-&gt;readersGo, &amp;rwLockPtr-&gt;lock, RK_WAIT_FOREVER);
	    /* mutex is locked when waking up*/
	}
	/* increase rwCount, so its &gt; 0, indicating readers */
	rwLockPtr-&gt;rwCount ++;
	kMutexUnlock(&amp;rwLockPtr-&gt;lock);
}

/* a reader releases and wake a single writer */
/* if it is the last reader */
VOID RwLockReleaseRead(RwLock_t *const rwLockPtr)
{
	kMutexLock(&amp;rwLockPtr-&gt;lock, RK_WAIT_FOREVER);
	rwLockPtr-&gt;rwCount --;
	if (rwLockPtr-&gt;rwCount == 0)
	{
		kEventSignal(&amp;rwLockPtr-&gt;writersGo);
	}
	kMutexUnlock(&amp;rwLockPtr-&gt;lock);
}</code></pre>
</div>
</div>
<div class="paragraph data-line-1596">
<p>In the image below, 4 tasks&#8201;&#8212;&#8201;a faster writer (Task 1, priority 1), a slow writer (Task 4, priority 4) and two readers (Task2 and 3, both priority 2)&#8201;&#8212;&#8201;reading from and writing to a shared UINT variable:</p>
</div>
<div class="imageblock data-line-1598">
<div class="content">
<img src="https://kernel0org.wordpress.com/wp-content/uploads/2025/06/readerwriter-4.png" alt="readerwriter 4" width="30%">
</div>
</div>
</div>
</div>
<div class="paragraph data-line-1601">
<p>Both examples above are useful generalisations you can reuse.</p>
</div>
</div>
</div>
<div class="sect2 data-line-1604">
<h3 id="scheduler_lock">3.5. Scheduler Lock</h3>
<div class="paragraph data-line-1606">
<p>Often we need a task to perform atomic operations, it cannot be preempted. A mutex serialises access to a code region, but does not prevent a task from being preempted while modifying the data, what often can lead to an inconsistent state. An aggressive way is to disable interrupts globally; while sometimes it is necessary, it creates blind spots as the system will be unresponsive. On application level it is an option for very short operations and when you need to protect data from interrupts altogether.</p>
</div>
<div class="paragraph data-line-1608">
<p>A less aggressive approach is to make the task non-preemptible issuing <code>kSchLock()</code> before entering the critical region and
<code>kSchUnlock()</code> when leaving. This way, interrupts are still being sensed and even higher priority tasks might switch to a ready state, but the current task will not be preempted. The priority inversion it causes has its <em>worst-case</em> bounded to the time elapsed between the lock is acquired, until the next system tick after it is released.</p>
</div>
<hr>
<div class="admonitionblock note data-line-1614">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-1616">
<p><em><strong>Message Passing</strong></em></p>
</div>
<div class="paragraph data-line-1618">
<p>In real-time applications, Message Passing often encounters the following scenarios:</p>
</div>
<div class="ulist data-line-1620">
<ul>
<li class="data-line-1620">
<p>Some messages are consumed by tasks that can&#8217;t do anything before processing information — thus, these messages end up also being signals. For Example, a server needs (so it blocks) for a command to process and/or a client that blocks for an answer.</p>
</li>
<li class="data-line-1622">
<p>A particular case of the above scenario is fully synchronous: client and server run on <em>lockstep</em>.</p>
</li>
<li class="data-line-1624">
<p>Two tasks with different rates need to communicate, and cannot lockstep. A faster producer might use a buffer to accommodate a relatively small burst of generated data, or a quicker consumer will drop repeated received data.</p>
</li>
<li class="data-line-1626">
<p>Other times, we need to correlate data with time for processing, so using a queue gives us the idea of data motion. <em>Eg., when calculating the mean value of a transductor on a given period</em>.</p>
</li>
<li class="data-line-1628">
<p>For <em>real-time</em> tasks such as servo-control loops, past data is useless. Consumers need the most recent data for processing. For example, a <em>drive-by-wire</em> system, or a robot deviating from obstacles. In these cases the message-passing must be lock-free while guaranteeing data integrity.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock note data-line-1632">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist data-line-1633">
<ul>
<li class="data-line-1633">
<p>The message passing mechanisms do not reuse any of the mechanisms presented so far.</p>
</li>
<li class="data-line-1635">
<p>The same <code>try</code> semantics applies when using <code>RK_NO_WAIT</code> timeout option.</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2 data-line-1638">
<h3 id="mailbox">3.6. Mailbox</h3>
<table class="tableblock frame-all grid-all stretch data-line-1640">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Mailbox Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Mail Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner Task*</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-1647">
<p>While in GPOS jargon, mailboxes are queues of messages - as a distinction from pipes (that are byte streams) - in embedded system software, often mailboxes are said to have a capacity of a single item, and more recently, you will not find it as a distinct mechanism - you use a 1-item queue.</p>
</div>
<div class="paragraph data-line-1649">
<p>A Mailbox allows a task to exclusively write (post) and read (pend) a memory region and to be notified when another task writes or reads to it. Therefore its typical operation provides mutual exclusion and notification altogether: <em>very handy</em>.</p>
</div>
<div class="paragraph data-line-1651">
<p>A message within a mailbox is the address of an object. The sender and receiver agree on the concrete mail implementation as part of the mail interface contract; also the data pointed to has to remain unchanged until the receiver 'consumes' it. That is another part of the contract.</p>
</div>
<div class="paragraph data-line-1653">
<p>The semantics are simple: a Mailbox will be <code>EMPTY</code> when its storage points to <code>NULL</code>; otherwise, it is <code>FULL</code>. The mailbox will be empty/full after a successful <code>pend()</code>/<code>post()</code> operation.</p>
</div>
<div class="paragraph data-line-1655">
<p>When a producer <code>post()</code> to a <code>FULL</code> mailbox, it (optionally) blocks and is placed in the Mailbox waiting queue. The associated task will switch to the state <code>SENDING</code>.</p>
</div>
<div class="paragraph data-line-1657">
<p>Likewise, a consumer (optionally) blocks when issuing a <code>pend()</code> on an empty Mailbox. The task status switches to <code>RECEIVING,</code> and is enqueued in the mailbox waiting queue.</p>
</div>
<div class="admonitionblock note data-line-1660">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A mailbox can be initialised as FULL if the initial pointer provided is non-null.
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-1662">
<p>Typical use-case is when one wants to deliver a signal along with a payload&#8212;&#8203;a <em>message as a signal</em>.</p>
</div>
<div class="paragraph data-line-1665">
<p>Besides <code>post()</code> and <code>pend()</code>, other primitives are <code>peek()</code> to read without removing (non-destructive) and <code>postovw()</code> to overwrite whatever is in a full mailbox.</p>
</div>
<div class="paragraph data-line-1668">
<p><em>* we discuss ownership on message passing later.</em></p>
</div>
<div class="admonitionblock tip data-line-1671">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-1672">
<p>Passing Messages by reference is a typical “embedded thing” – because it is cheap, deterministic and DMA-friendly.</p>
</div>
</td>
</tr>
</table>
</div>
<hr>
<div class="exampleblock data-line-1676">
<div class="content">
<div class="listingblock data-line-1678">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/****************************************************
 *
 *  RK0 v0.5.0 - Profiling Testbench
 *
 *  MCU: STM32F103RB @ 64MHz | 1ms tick
 *
 * Priority level:
 * (highest)-----------------------------&gt;(lowest)
 *         Task1, Task2, Task3, Task4, Task5
 *
 * Description:
 *
 * Mailboxes passing tokens as signals to coordinate.
 *
 * If the mechanism is deterministic,
 * counters will be within 1 from each other.
 *
 * Mailbox are initialised empty.
 *  kMboxInit(&amp;mbox1, NULL);
 *  kMboxInit(&amp;mbox2, NULL);
 *	kMboxInit(&amp;mbox3, NULL);
 *	kMboxInit(&amp;mbox4, NULL);
 *	kMboxInit(&amp;mbox5, NULL);
 *
 **************************************************/


VOID Task1( VOID *args)
{
	RK_UNUSEARGS
	UINT *p;
	while (1)
	{
		counter1++;
		kMboxPend(&amp;mbox1, (VOID*) &amp;p, RK_WAIT_FOREVER);
	}
}

VOID Task2( VOID *args)
{
	RK_UNUSEARGS
	UINT mesg = 1;
	UINT *p;

	while (1)
	{
		kMboxPost(&amp;mbox1, &amp;mesg, RK_WAIT_FOREVER);

		counter2++;

		kMboxPend(&amp;mbox2, (VOID*) &amp;p, RK_WAIT_FOREVER);

	}
}
VOID Task3( VOID *args)
{
	RK_UNUSEARGS
	UINT mesg = 1;
	UINT *p;
	while (1)
	{

		kMboxPost(&amp;mbox2, &amp;mesg, RK_WAIT_FOREVER);

		counter3++;

		kMboxPend(&amp;mbox3, (VOID*) &amp;p, RK_WAIT_FOREVER);

	}
}

VOID Task4( VOID *args)
{
	RK_UNUSEARGS
	UINT mesg = 1;
	UINT *p;
	while (1)
	{

		kMboxPost(&amp;mbox3, &amp;mesg, RK_WAIT_FOREVER);

		counter4++;

		kMboxPend(&amp;mbox4, (VOID*) &amp;p, RK_WAIT_FOREVER);

	}
}
VOID Task5( VOID *args)
{
    RK_UNUSEARGS
    UINT mesg=1;
    while(1)
	{

		kMboxPost(&amp;mbox4, &amp;mesg, RK_WAIT_FOREVER);
		counter5++;

	}
}</code></pre>
</div>
</div>
</div>
</div>
<div class="imageblock data-line-1785">
<div class="content">
<img src="https://kernel0org.wordpress.com/wp-content/uploads/2025/06/mboxbench.png" alt="mboxbench">
</div>
</div>
<hr>
<div class="sect3 data-line-1789">
<h4 id="usage_example_zero_buffer_channel">3.6.1. Usage Example: <em>Zero-Buffer</em> Channel</h4>
<div class="paragraph data-line-1791">
<p>Some communications are unreliable or important enough so we need guarantees that not only the message could be sent, but also that it could be read.</p>
</div>
<div class="paragraph data-line-1793">
<p>On a <em>zero-buffer</em> channel we do not allow messages to be waiting so they are picked. The sender blocks, waiting for a confirmation that the message was retrieved by the receiver:</p>
</div>
<div class="exampleblock data-line-1795">
<div class="content">
<div class="listingblock data-line-1796">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">*/

/* sender needs to be sure message has arrived */
SenderTask:

   err = kMboxPost(...., timeout);
   if (err=ERR_TIMEOUT)
       retryPost();
   if (err==success)
   {
       /* pend on private bin semaphore, to wait for confirmation it was read */
       err = kPend(timeout);
       if (err == ERR_TIMEOUT)
       /* receiver did not ack before time-out */

   }


ReceiverTask:
    err = kMboxPend( ..., timeout);
    if (err==ERR_TIMEOUT)
        retryPend();
    if(err==SUCCESS)
       /* post to sender's semaphore, to ack message was received */
       kSignal(senderTaskHandle);


/* using a mailbox instead of a binary semaphore */


K_MBOX reqBox; /* request message */
K_MBOX ackBox; /* ack message */

SenderTask:

   err = kMboxPost(&amp;reqBox, &amp;reqMesg, timeout);
   if (err=ERR_TIMEOUT)
       retryPost();
   if (err==SUCCESS)
   {
       /* the acknowledgment mail can be a dummy message */

       err = kMboxPend(&amp;ackBox, &amp;recvmesg, timeout);
       if (err == ERR_TIMEOUT)
       /* receiver did not ack before time-out */

   }


ReceiverTask:
    err = kMboxPend( ..., timeout);
    if (err==ERR_TIMEOUT)
        retryPend();
    if(err==SUCCESS)
    {
       err = kMboxPost(&amp;ackBox, &amp;ackMesg, timeout);
       if (err==ERR_TIMEOUT)
       /* in this case, the sender has not retrieved
          a previous ack */
    }</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-1862">
<p>Mailboxes are well-suited for 1:1 communication - fully synchronous (lockstep) command-response or when a task waits for a notification plus a payload (say, the last data read by an Interrupt routine).</p>
</div>
</div>
<div class="sect3 data-line-1864">
<h4 id="example_multi_client_server_synchronous_command_response">3.6.2. Example: Multi-client-server synchronous command-response</h4>
<div class="paragraph data-line-1866">
<p>The snippet below presents <em>two clients</em> and one server on a lock-step communication.</p>
</div>
<div class="paragraph data-line-1868">
<p>It is shown to stress how data scope is kept and can be lost. In this case,
<em>both client and server blocking for a response/ACK</em> keeps the data scope.</p>
</div>
<div class="exampleblock data-line-1872">
<div class="content">
<div class="listingblock data-line-1874">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* this example includes  &lt;string.h&gt; for convenience */

RK_MBOX serverReqMbox; /*  server incoming commands */
RK_MBOX serverAckMbox; /*  server incoming reponse acks */
RK_MBOX clientMbox1;   /*  response for client 1 */
RK_MBOX clientMbox2;   /* response for client 2 */

/* Command Requests are assembled on an Application Data Unit */
typedef struct
{
    BYTE length; /* Length of the APDU payload */
    BYTE payload[32]; /* APDU payload */
    RK_MBOX *replyMbox; /* Pointer to the client's reply mailbox */
} APDU __K_ALIGN(4);

void kApplicationInit(VOID)
{
    kMboxInit(&amp;serverReqMbox,  NULL);
    kMboxInit(&amp;serverAckMbox, NULL);
    kMboxInit(&amp;clientMbox1, NULL);
    kMboxInit(&amp;clientMbox2, NULL);

}

/* Highest Priority */
/* the server response is to ECHO the request back to the client; then it pends on a mailbox waiting the client to acknowledge the response. so it proceeds to process further requests.  */

VOID ServerTask(VOID* args)
{
    RK_UNUSEARGS

    APDU *request, response;
    UINT* ackResp;
    while (1)
    {
        /* Wait for a request */
        if (kMboxPend(&amp;serverReqMbox, (VOID **)&amp;request, RK_WAIT_FOREVER) == RK_SUCCESS)
        {
            kprintf("[SERVER] RECV: %s\r\n", request-&gt;payload);

            /* Process the request */
            response.length = (BYTE) snprintf((char*) response.payload,
                    sizeof(response.payload), "ECHO %s",
                    request-&gt;payload);

            /* Echo to client's reply mailbox */
            if (kMboxPost(request-&gt;replyMbox, &amp;response, RK_WAIT_FOREVER) != RK_SUCCESS)
            {
                kprintf("ECHO fail\r\n");
            }
            if (kMboxPend(&amp;serverAckMbox, (VOID **)&amp;ackResp, RK_WAIT_FOREVER) == RK_SUCCESS)
                kprintf("[SERVER] CLIENT %d SERVED.\r\n", *ackResp);
            /* now it is safe to process another request */
        }
    }
}
/* same priority as Client2 */
VOID Client1Task(VOID* args)
{
    RK_UNUSEARGS

    APDU request, *response;

    while (1)
    {
        /* Prepare the request */
        snprintf((char*) request.payload, sizeof(request.payload),
                "Hello from Client 1");
        request.length = (BYTE) strlen((char*) request.payload);
        request.replyMbox = &amp;clientMbox1; /* Specify the reply mailbox */

        /* Send the request to the server */
        if (kMboxPost(&amp;serverReqMbox, &amp;request, RK_WAIT_FOREVER) == RK_SUCCESS)
        {

            /* Wait for the response */
            if (kMboxPend(&amp;clientMbox1, (VOID **)&amp;response, RK_WAIT_FOREVER)
                    == RK_SUCCESS)
            {
                kprintf("[CLIENT #1] RECV: %s\r\n", response-&gt;payload);
                UINT ack=1;
                kMboxPost(&amp;serverAckMbox, &amp;ack, RK_WAIT_FOREVER);
                /* now it is safe to send another request */
            }
            else
            {
                kprintf("1F\r\n");
            }
        }
        else
        {
            kprintf("1F\r\n");
        }

    }
}
VOID Client2Task(VOID* args)
{
    RK_UNUSEARGS
    APDU request, *response;

    while (1)
    {
        /* Prepare the request */
        snprintf((char*) request.payload, sizeof(request.payload),
                "Hello from Client 2");
        request.length = (BYTE) strlen((char*) request.payload);
        request.replyMbox = &amp;clientMbox2; /* Specify the reply mailbox */

        /* Send the request to the server */
        if (kMboxPost(&amp;serverReqMbox, &amp;request, RK_WAIT_FOREVER) == RK_SUCCESS)
        {

            /* Wait for the response */
            if (kMboxPend(&amp;clientMbox2, (VOID **)&amp;response, RK_WAIT_FOREVER)
                    == RK_SUCCESS)
            {
                kprintf("[CLIENT #2] RECV: %s\r\n", response-&gt;payload);
                UINT ack=2;
                kMboxPost(&amp;serverAckMbox, &amp;ack, RK_WAIT_FOREVER);
            }
            else
            {
                kprintf("2FAIL\r\n");
            }
        }
        else
        {
            kprintf("2FAIL\r\n");
        }

    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="imageblock data-line-2011">
<div class="content">
<img src="images/images/clientserver.png" alt="clientserver" width="30%">
</div>
</div>
<div class="paragraph data-line-2013">
<p>Had the server not block waiting for an ACK, the former response would be overwritten before a client could have read it - given how priorities are set. To accomodate two clients while still passing by reference, the server would need to keep the response on different buffers.</p>
</div>
<div class="paragraph data-line-2015">
<p>If a copy was passed as a reponse, the server would not need to block for an ACK, provided the response was sent before receiving another request.</p>
</div>
</div>
</div>
<div class="sect2 data-line-2018">
<h3 id="signals_as_a_direct_channel">3.7. Signals as a Direct Channel</h3>
<div class="paragraph data-line-2020">
<p><em>Direct Signals</em> is the only Inter-Task Communication service that is always enabled. It can also be used for a message-passing&#8201;&#8212;&#8201;and no, it is not a "hack".</p>
</div>
<div class="paragraph data-line-2022">
<p>The kernel does not provide it as a explicit service though, because there at least two well-defined semantics that can be used: either first-message semantics, or last-message semantics. <em>The user knows better</em>.</p>
</div>
<div class="paragraph data-line-2024">
<p>A <em>possible</em> pattern is as follows&#8201;&#8212;&#8201;in this case an <em>unbuffered direct channel</em>:</p>
</div>
<div class="exampleblock data-line-2026">
<div class="content">
<div class="listingblock data-line-2027">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* first-message semantics */
RK_ERR SendMesg(RK_TASK_HANDLE const taskHandle, ULONG const mesg)
{
    /* return error if there is a message */
    /* for last message semantics, skip this check */
    ULONG query=0;
    RK_ERR err = kSignalQuery(taskHandle, &amp;query);
    if (err &lt; 0)
        return (err);
    if (query != 0) /* receiver is 'full' */
        return (RK_ERROR);
    err = kSignalSet(taskHandle, mesg);
    return (err);
}


RK_ERR RecvMesg(ULONG *const recvPtr, RK_TICK const timeout)
{
    /* require all bits set, wait for any, when returning
    all bits are cleared */
    RK_ERR err = kSignalGet(0xFFFFFFFF, RK_FLAGS_ANY, recvPtr, timeout);
    return (err);
}

/*****

Note that ZERO is not a valid parameter for a Signal.

You can establish a contract such as splitting the 32-bit message on different fields; besides, you can always pass a pointer:

*****/


/* EXAMPLE: fully synchronous message-passing */

struct mesg
{
    RK_TASK_HANDLE senderHandle;
    CHAR   mesg[8];

    /* others fields */

} __K_ALIGN(4);

typedef struct mesg Mesg_t;

#define ACK 0x01U

VOID RecvTask( VOID *args)
{
    RK_UNUSE_ARGS

    ULONG recvMesg = 0;

    while(1)
    {
        /* pend for receiving */
        RecvMesg(&amp;recvMesg, RK_WAIT_FOREVER);

        /* cast 4-byte received to Mesg_t* */
        Mesg_t* recvMesgPtr = (Mesg_t*) recvMesg;

        /* ... work(recvMesgPtr) ... */

        /* ack reception */
        kSignalSet(recvMesgPtr-&gt;senderHandle, ACK);

    }
}


VOID SenderTask( VOID *args)
{
    RK_UNUSE_ARGS

    Mesg_t sendMesg = {0};

    while(1)
    {
        /* ... generate message... */


        /* pass the address of sendMesg as a ULONG */
        RK_ERR err = SendMesg(recvTaskHandle, (ULONG)&amp;sendMesg);

        /* block for an ACK */
        kSignalGet(ACK, RK_FLAGS_ALL, NULL, RK_WAIT_FOREVER);

    }

}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-2122">
<h3 id="message_queues">3.8. Message Queues</h3>
<div class="paragraph data-line-2124">
<p>The classic Message Queue on UNIX SVR4 is defined as the 'head of a linked list of messages'. Some RTOSes implement Message Queues using linked lists, in which case a central pool of buffers might exist.</p>
</div>
<div class="paragraph data-line-2126">
<p>The design approach in RK0 does not use lists for message queues &#8201;&#8212;&#8201;lists add processing and memory overhead and are suitable for <em>unbounded</em> queues.</p>
</div>
<div class="paragraph data-line-2128">
<p>As <em>unbounded</em> is a forbidden word in <em>RK0</em> design, every message queue has a fixed capacity along with a <em>dedicated</em> pool of buffers, avoiding contention.</p>
</div>
<div class="paragraph data-line-2130">
<p>Two mechanisms for enqueueing messages are offered:</p>
</div>
<div class="ulist data-line-2132">
<ul>
<li class="data-line-2132">
<p>A <em>Mail Queue</em> (or a <em>Queue</em>) is a 'multi-item' Mailbox—it holds multiple generic pointers as messages.</p>
</li>
<li class="data-line-2134">
<p>A <em>Stream Queue</em> (or a <em>Stream</em>) is a ring buffer of N fixed-size messages (word-aligned). <em>Streams perform deep copies</em> - from sender storage to the stream buffer, and from the stream buffer to receiver storage.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2136">
<p>They are offered as different mechanisms because they have different best-use cases and semantics.</p>
</div>
<div class="sect3 data-line-2139">
<h4 id="mail_queue">3.8.1. Mail Queue</h4>
<table class="tableblock frame-all grid-all stretch data-line-2142">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Queue Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Buffer Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write Position</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read Position</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Max. number of mails</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current number of mails</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Waiting queue</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner Task</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-2153">
<p>Mail Queues (or just <em>Queues</em>) are Mailboxes that can hold several messages in a FIFO queue. Indeed, a Mail Queue with a size of 1 will behave as a Mailbox.</p>
</div>
<div class="paragraph data-line-2155">
<p>The programmer must provide a buffer to hold N message addresses for a Queue. The main primitives are <code>post(), pend(), peek(), and jam().</code></p>
</div>
<div class="paragraph data-line-2157">
<p><em>Peek</em> reads the Queue front message without extracting it, and <em>Jam</em> places a message on the queue front so that this message will be <em>Last-In-First-Out</em>.</p>
</div>
<div class="paragraph data-line-2159">
<p>Mails will be enqueued in a FIFO order (except when using <code>jam()</code>).</p>
</div>
<div class="admonitionblock note data-line-2162">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph data-line-2163">
<p>A single-slot Queue behaves as a Mailbox. Still Mailboxes are provided as a distinct service from Queues because a Queue Control Block is roughly three times larger than a Mailbox, plus Queue methods are considerably heavier. As Mailboxes are extremely handy, providing them as a standalone mechanism allows composing them with other features while keeping Queues disabled entirely.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2166">
<p>For both Queues and Mailboxes, if your message is a 4-byte message&#8201;&#8212;&#8201;such as an UINT value&#8201;&#8212;&#8201;they can (and probably should) be passed by copy: just cast to (VOID*) when transmitting, and cast back to UINT when receiving. <em>Yet, this should be an option only if you are unwilling to use Streams.</em></p>
</div>
<div class="sect4 data-line-2168">
<h5 id="usage_example_asynchronous_zero_copy_message_passing">3.8.1.1. Usage Example: Asynchronous 'Zero-copy' Message Passing</h5>
<div class="paragraph data-line-2170">
<p>Queues purpose is to transmit the pointer of a message that is kept on a memory block. Two example below demonstrates its usage.</p>
</div>
<div class="exampleblock data-line-2172">
<div class="content">
<div class="listingblock data-line-2173">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">struct mesg
{
    UINT key;
    const CHAR* string; /* a shallow copy will not get this */
};

#define N_MESG 8
#define MESG_SIZE sizeof(struct mesg)

BYTE mesgPool[N_MESG][MESG_SIZE]; /* pool of mesg buffers */
struct mesg* buf[N_MESG]; /* to store addresses */

RK_MEM mem; /* allocator */
RK_QUEUE mqueue; /* queue */

/* for testbench */
const CHAR *messages[N_MESG] =
{ "Message 0", "Message 1", "Message 2", "Message 3", "Message 4", "Message 5",
        "Message 6", "Message 7" };

VOID kApplicationInit(VOID)
{
    /* init allocator */
    kMemInit(&amp;mem, (VOID *) mesgPool, MESG_SIZE, N_MESG);
    /* init mailbox */
    kQueueInit(&amp;mqueue, (VOID *) buf, 8);
}
VOID Task1(VOID* args)
{
    RK_UNUSEARGS
    UINT i = 0;
    struct mesg *sendPtr;
    while (1)
    {
        /* allocate buffer */
        sendPtr = NULL;
        /* sendPtr points to a pool mesgPool address */
        sendPtr = (struct mesg*) kMemAlloc(&amp;mem);
        if (sendPtr != NULL)
        {

            sendPtr-&gt;key = i;
            sendPtr-&gt;string = messages[i];
            kprintf("Sending: %s \r\n", sendPtr-&gt;string);
            /* mesgPool address is enqueued */
            kQueuePost(&amp;mqueue, sendPtr, RK_WAIT_FOREVER);
            i += 1;
            i %= N_MESG;
        }
        else
        {
            kYield(); /* no more mesg buffers, yield */
        }
    }
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
    struct mesg *recvPtr = NULL;
    while (1)
    {
        kQueuePend(&amp;mqueue, (VOID **) &amp;recvPtr, RK_WAIT_FOREVER); /* will block when empty */
        kprintf("Received: %s \r\n", recvPtr-&gt;string);
        kBusyDelay(2); /* pretend working */
        kMemFree(&amp;mem, (VOID *) recvPtr); /* free memory */
    }
}</code></pre>
</div>
</div>
<div class="imageblock data-line-2245">
<div class="content">
<img src="images/images/mboxqueue.png" alt="mboxqueue" width="25%">
</div>
</div>
</div>
</div>
<div class="paragraph data-line-2248">
<p>The data scope is managed by allocating a different buffer for every <code>post()</code>, and the receiver is accountable for deallocating the buffer after consuming the message.
The receiver gets an address of a message. The design must guarantee its integrity. After consuming the contents, the receiver frees the memory block.</p>
</div>
</div>
<div class="sect4 data-line-2251">
<h5 id="usage_example_work_queue">3.8.1.2. Usage Example: Work Queue</h5>
<div class="paragraph data-line-2253">
<p>This example demonstrates how to implement a work queue pattern using a Mail Queue.</p>
</div>
<div class="paragraph data-line-2255">
<p>Multiple producer tasks (Sensor, PID Controller, and UI) create Job_t objects and submit their addresses to a Mail Queue (jobQueue).</p>
</div>
<div class="paragraph data-line-2257">
<p>In this example the worker thread is logging what is happening on the system. As it runs on lowest priority, it keeps the system responsiveness with minimal intrusion.</p>
</div>
<div class="paragraph data-line-2259">
<p>The same pattern can support actual processing. You could either embed a function pointer in each job for fully dynamic behaviour, or define a command ID and use a central dispatch table in the worker thread to invoke appropriate handlers. These are all implementations of the <em>Active Object Pattern</em>.</p>
</div>
<div class="exampleblock data-line-2261">
<div class="content">
<div class="listingblock data-line-2263">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* Job_t and queue definitions */
#define MAX_JOBS 8

typedef struct {
    BYTE length;
    BYTE payload[64];
} Job_t;

static Job_t jobPoolBuf[MAX_JOBS];
static RK_MEM jobPool;
static Job_t *jobQueueBuf[MAX_JOBS];
static RK_QUEUE jobQueue;

/* Plant model state */
static volatile FLOAT plantTemp = 25.0f;
static const FLOAT ambientTemp = 20.0f;

/* Convert plantTemp to integer for logging */
INT readTemp(VOID)
{
    return (INT)plantTemp;
}

/* Simulate button every 2s */
INT buttonPressed(VOID)
{
    return ((kTickGet() % 2000) &lt; 20); /* the condition will hold true for 20ms every 2s */
}

VOID kApplicationInit( VOID)
{
    kMemInit( &amp;jobPool, jobPoolBuf, sizeof(Job_t), MAX_JOBS);
    kQueueInit( &amp;jobQueue, jobQueueBuf, MAX_JOBS);
}

/* PID Controller Task (High priority) */
/* note: this is a sloppy zero-effort tunning
just for printing something */
VOID PIDControllerTask( VOID *args)
{
    RK_UNUSEARGS

    const FLOAT Kp=1.0f, Ki=0.1f, Kd=0.05f;
    FLOAT prev=plantTemp;
    FLOAT integral=0.0f;
    const FLOAT dt=0.5f;

    while(1)
    {
        /* Read plant state */
        FLOAT measure = plantTemp;
        /* PID compute */
        FLOAT error = 25.0f - measure;
        integral += error * dt;
        FLOAT derivative = (measure - prev) / dt;
        FLOAT output = Kp*error + Ki*integral - Kd*derivative;
        prev = measure;

        /* Apply to plant model */
        /* the plant cooling model: (temp-amb)*0.1  */
        plantTemp += (output - (plantTemp - ambientTemp)*0.1f) * dt;

        /* Post log job */

        Job_t *jobPtr = kMemAlloc( &amp;jobPool);
        if(jobPtr)
        {
            CHAR buf[32];
            formatFloat (buf, sizeof(buf), output);
            snprintf( (CHAR*)jobPtr-&gt;payload, sizeof(jobPtr-&gt;payload),
                     "[CTRL] O=%s T=%d", buf, readTemp());
            jobPtr-&gt;length = strlen((CHAR*)jobPtr-&gt;payload);
            if(kQueuePost( &amp;jobQueue, job, RK_NO_WAIT) != RK_SUCCESS)
            {
            /*as the worker thread is freeing the memory blocks
             if the queue is full and we do not want to block
             we free the allocated memory; otherwise it would leak
            */
                kMemFree( &amp;jobPool, job);
            }
        }
        kSleepUntil( 500);
    }
}

/* Sensor Task (Mid priority) */
VOID TempSensorTask( VOID *args)
{
    RK_UNUSEARGS
    while(1)
    {
        Job_t *jobPtr = kMemAlloc(&amp;jobPool);
        if(jobPtr)
        {
            snprintf( (CHAR*)jobPtr-&gt;payload, sizeof(jobPtr-&gt;payload),
                     "[SENSOR] T=%dC", readTemp());
            jobPtr-&gt;length = strlen((CHAR*)jobPtr-&gt;payload);
            if(kQueuePost( &amp;jobQueue, jobPtr, RK_NO_WAIT) != RK_SUCCESS)
            {
                kMemFree( &amp;jobPool, jobPtr);
            }
        }
        kSleepUntil(1000);
    }
}

/* UI Task (Low priority) */
/* this is to cause a temperature disturbance */
VOID UIButtonTask( VOID *args)
{
    RK_UNUSEARGS
    while(1)
    {
        if(buttonPressed())
        {
            plantTemp -= plantTemp*0.15f  /* disturb the temperature */
            Job_t *jobPtr = kMemAlloc( &amp;jobPool);
            if(jobPtr)
            {
                snprintf((CHAR*)jobPtr-&gt;payload, sizeof(jobPtr-&gt;payload),
                         "[BTN] Temp: %d", (INT)plantTemp);
                jobPtr-&gt;length = strlen((CHAR*)jobPtr-&gt;payload);
                if(kQueuePost( &amp;jobQueue, jobPtr, RK_NO_WAIT) != RK_SUCCESS)
                {
                    kMemFree( &amp;jobPool, jobPtr);
                }
            }
        }
        kSleepUntil( 2000);
    }
}

/* Worker Task (Lowest priority) */
VOID WorkerTask( VOID *args)
{
    RK_UNUSEARGS
    Job_t *jobPtr = NULL;
    while(1)
    {
        if(kQueuePend( &amp;jobQueue, (VOID**)&amp;jobPtr, RK_WAIT_FOREVER)==RK_SUCCESS)
        {
            printf("[WORKER] %s\r\n", jobPtr-&gt;payload);
            kMemFree( &amp;jobPool, jobPtr);
        }
    }
}</code></pre>
</div>
</div>
<div class="imageblock data-line-2416">
<div class="content">
<img src="images/images/workqueue.png" alt="workqueue" width="25%">
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3 data-line-2420">
<h4 id="stream_queue">3.8.2. Stream Queue</h4>
<table class="tableblock frame-all grid-all stretch data-line-2422">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Message Stream Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Storage address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Write Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Read Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Block Size</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Max of messages</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Count</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner Task</p></td>
</tr>
</tbody>
</table>
<div class="paragraph data-line-2432">
<p>Streams resemble classic (named) Pipes. The difference is that messages have <em>a fixed size</em>. On the other hand, pipes transmit and receive any number of bytes for each operation.</p>
</div>
<div class="paragraph data-line-2434">
<p>For each Stream, the user provides a buffer address with enough capacity (number of messages <em>x</em> message size). Ther kernel will handle it as a ring buffer.</p>
</div>
<div class="paragraph data-line-2436">
<p>The message size associated with a Message Stream instance is defined on its initialisation. On transmission, a <em>deep copy</em>  of a message from the sender&#8217;s storage to the queue takes place; on reception, it moves from the queue to the receiver&#8217;s storage.</p>
</div>
<div class="admonitionblock note data-line-2439">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although a message size is associated with a Stream Queue object, the concrete message type depends on the application.
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2442">
<p>The important primitives for Message Streams are <code>send()</code>, <code>recv()</code>, <code>jam()</code> and <code>peek()</code>.</p>
</div>
<div class="paragraph data-line-2444">
<p>Sending to a full queue (optionally) blocks the sender. Likewise, receiving from an empty queue.</p>
</div>
<div class="sect4 data-line-2446">
<h5 id="stream_message_size">3.8.2.1. Stream Message-Size</h5>
<div class="paragraph data-line-2448">
<p><strong>Stream Queues must have <em>fixed</em> message-sizes multiples of a <em>WORD</em>. Besides, they must be a power-of-two: 1, 2, 4, 8, 16, 32&#8230;&#8203; (words).</strong></p>
</div>
<div class="paragraph data-line-2450">
<p><em>RK0</em> does not establish an upper bound, although I would say that a good cap is 8 words for the regular <em>RK0</em> target. One has to experiment, though. If a message becomes too large it is introducing prohibitive latency, the user needs to transmit the message address - i.e., configure the Stream to carry 1-word message-size.</p>
</div>
<div class="ulist data-line-2452">
<ul>
<li class="data-line-2452">
<p>Load/Store instructions are optimised to fetch 32-bit words. If message size are bounded on a 4-byte boundary, these operations can be executed in a single cycle.</p>
</li>
<li class="data-line-2454">
<p>If larger than 1 word, the power-of-two (double-word), is a CPU-aware design choice  to prevent unalignment issues.</p>
</li>
<li class="data-line-2456">
<p>Misaligned memory makes castings unsafe, leading to complex faults, performance penalties or undefined behaviour.</p>
</li>
</ul>
</div>
<div class="admonitionblock tip data-line-2461">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-2462">
<p>Deep Copies are usually needed on message passing, but introduce significant overhead.</p>
</div>
<div class="paragraph data-line-2464">
<p>Design choice: Be CPU-aware and constrain data-size to power-of-two words.</p>
</div>
<div class="paragraph data-line-2466">
<p>Benefits: speeds up the copy, achieves more deterministic behaviour, improves run-time safety.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2470">
<p>Code-wise, we optimise using pointer arithmetics on pointer to words:</p>
</div>
<div class="listingblock data-line-2472">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* Optimised deep copy; guaranteed mesgSize&gt;0 */
/* destPtr and srcPtr are pointers to a word */
#define RK_CPY(destPtr, srcPtr, mesgSize) \
do {                                   \
      while (--mesgSize)               \
      {                                \
     /* if mesgSize is 1, this is NOT executed */
        *(destPtr++) = *(srcPtr++)     \
      };                               \
     /* the last or the only copy is executed now */
     *(destPtr++) = *(srcPtr++)       \
     DMB \ /* ensure order  */
   } while(0U)</code></pre>
</div>
</div>
</div>
<div class="sect4 data-line-2489">
<h5 id="usage_example_averaging_sensor_values">3.8.2.2. Usage Example: Averaging Sensor Values</h5>
<div class="paragraph data-line-2491">
<p>Below is an illustrative snippet of a <em>Queueing Pattern</em>.</p>
</div>
<div class="paragraph data-line-2493">
<p>The goal is to calculate the average value of 4 types of sensors.</p>
</div>
<div class="paragraph data-line-2495">
<p>Here is convienient to highlight an important aspect&#8201;&#8212;&#8201;given its reactive nature, real-time system software is typically <em>I/O bounded</em>, tasks that are sensitive to I/O activity have higher priority than <em>CPU-bounded</em> tasks, i.e., those processing data.</p>
</div>
<div class="paragraph data-line-2497">
<p>A task receives measured sensor values from an ISR on a periodic rate. (The ISR is emulated by a Soft Timer).</p>
</div>
<div class="paragraph data-line-2499">
<p>Then it enqueues this data to a consumer - that will process the average value for each of 4 sensors.</p>
</div>
<div class="paragraph data-line-2501">
<p>The inter-task communication is designed as follows:</p>
</div>
<div class="olist arabic data-line-2503">
<ol class="arabic">
<li class="data-line-2503">
<p>The producer pends on a Mailbox that ISR posts to.</p>
</li>
<li class="data-line-2505">
<p>The data extracted from the Mailbox is placed on a queue that has the processing task as the consumer.</p>
</li>
<li class="data-line-2507">
<p>As the producer priority must be higher than the consumer, eventually the queue will get full.</p>
</li>
<li class="data-line-2509">
<p>The first enqueued item is received by the consumer; then it pends on its private binary semaphore, when the dequeue operation results on an empty queue error.</p>
</li>
<li class="data-line-2511">
<p>From now on, the consumer will only be activated when the queue is full - the producer checks the number of items within the queue and signals the consumer.</p>
</li>
<li class="data-line-2513">
<p>This is done with a purpose: the consumer will use the inactive producer time to offload the queue and process the average value.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2515">
<p>Here the queue size was set as 8 items. This is an arbritrary value; the optimal queue size would take into account the producer-consumer ratio and the worst execution time of both.</p>
</div>
<div class="exampleblock data-line-2518">
<div class="content">
<div class="listingblock data-line-2519">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">#define kPend(timeout) \
	do { kSignalGet(0x1, RK_FLAGS_ANY, NULL, timeout); } while(0)

#define kSignal(taskhandle) \
	do { kSignalSet(taskhandle, 0x01); } while(0)

typedef enum
{
	TEMPERATURE=1, HUMIDITY, CO2, FLOW
}SensorType_t;



/* sensor types */
struct sensorMsg
{
    SensorType_t sensorType;
    ULONG sensorValue;

};

typedef struct sensorMsg Mesg_t;

#define N_MESSAGE 8
#define MESSAGE_SIZE (sizeof(Mesg_t))/4 /* WORDS! */
#define N_SENSOR    4
#define AVG_WINDOW_SIZE   10 /* 10 samples */

RK_STREAM sensorStream;/* the stream kobject */
Mesg_t mesgBuf[N_MESSAGE] = {0};/* queue buffer */
RK_TIMER timerT1;
RK_MBOX sensorBox;
static Mesg_t sample = {0};
static UINT sampleErr;
VOID callBackISR( VOID *args)
{
    RK_UNUSEARGS
    sample.sensorType = (rand() % 4) + 1;
    switch (sample.sensorType)
    {
        case TEMPERATURE:
            sample.sensorValue = ( ULONG) rand() % 50;
            break;
        case HUMIDITY:
            sample.sensorValue = ( ULONG) rand() % 100;
            break;
        case CO2:
            sample.sensorValue = ( ULONG) rand() % 1000;
            break;
        case FLOW:
            sample.sensorValue = ( ULONG) rand() % 10;
            break;
        default:
            break;
    }
    RK_ERR err = kMboxPost( &amp;sensorBox, &amp;sample, RK_NO_WAIT);
    if (err != RK_SUCCESS)
        sampleErr ++;

}

VOID kApplicationInit( VOID)
{
    RK_ERR err = kStreamInit( &amp;sensorStream, ( VOID*) mesgBuf, MESSAGE_SIZE,
    N_MESSAGE);
    kassert( err==RK_SUCCESS);
    err = kTimerInit( &amp;timerT1, 3, 3, callBackISR, NULL, RK_TIMER_RELOAD);
    kassert( err==RK_SUCCESS);
    err = kMboxInit( &amp;sensorBox, NULL);
    kassert( err==RK_SUCCESS);
}

VOID Task1( VOID *args)
{
    RK_UNUSEARGS
    Mesg_t *recvSample = NULL;
    while (1)
    {
        RK_ERR errmbox = kMboxPend( &amp;sensorBox, ( VOID**) &amp;recvSample,
                RK_WAIT_FOREVER);
        kassert( errmbox==RK_SUCCESS);
        ULONG nMesg = 0UL;
        kStreamQuery( &amp;sensorStream, &amp;nMesg);
        if (nMesg &lt;= N_MESSAGE - 1)
        {
            RK_ERR err = kStreamSend( &amp;sensorStream, &amp;sample, RK_NO_WAIT);
/* fill up queue and signal consumer task */
            if (err == RK_SUCCESS)
            {
                CHAR const *sensorTypeStr = NULL;
                if (recvSample-&gt;sensorType == 1)
                    sensorTypeStr = "TEMP";
                if (recvSample-&gt;sensorType == 2)
                    sensorTypeStr = "HUM";
                if (recvSample-&gt;sensorType == 3)
                    sensorTypeStr = "CO2";
                if (recvSample-&gt;sensorType == 4)
                    sensorTypeStr = "FLOW";

                RK_TICK_DIS
                kprintf( "ENQ: [@%d, %s, %lu] \r\n", kTickGet(), sensorTypeStr,
                        recvSample-&gt;sensorValue);
                RK_TICK_EN
            }
        }
        else
        {
            kSignal( task2Handle);
        }
    }
}

/* for each sensor:
 . a ring buffer of AVG_WINDOW_SIZE values
 . sum of values
 . an index table (=enum - 1 eg., HUMIDITY IDX=2-1=1)
 */
static ULONG ringBuf[N_SENSOR][AVG_WINDOW_SIZE];
static ULONG ringSum[N_SENSOR] = {0};
static UINT ringIndex[N_SENSOR] = {0};

void Task2( void *args)
{

    RK_UNUSEARGS
    Mesg_t readSample;
    while (1)
    {

        RK_ERR err = kStreamRecv( &amp;sensorStream, ( VOID*) &amp;readSample,
        RK_NO_WAIT);
        if (err == RK_SUCCESS)
        {
            UINT sensorIdx = readSample.sensorType - 1;

/* remove oldest sample */
            ULONG oldest = ringBuf[sensorIdx][ringIndex[sensorIdx]];
            ringSum[sensorIdx] -= oldest;

/* push new sample */
            ringBuf[sensorIdx][ringIndex[sensorIdx]] = readSample.sensorValue;
            ringSum[sensorIdx] += readSample.sensorValue;

/* index incr-wrap */
            ringIndex[sensorIdx] ++;
            ringIndex[sensorIdx] %= AVG_WINDOW_SIZE;

/* simple average */
            ULONG avg = ringSum[sensorIdx] / AVG_WINDOW_SIZE;

/* we disable tick to display */
            RK_TICK_DIS

            CHAR const *sensorTypeStr = NULL;
            if (readSample.sensorType == 1)
                sensorTypeStr = "TEMP";
            if (readSample.sensorType == 2)
                sensorTypeStr = "HUM";
            if (readSample.sensorType == 3)
                sensorTypeStr = "CO2";
            if (readSample.sensorType == 4)
                sensorTypeStr = "FLOW";

            kprintf( "DEQ: [@%d, %s, %lu] | AVG: %lu \r\n", kTickGet(),
                    sensorTypeStr, readSample.sensorValue, avg);

            RK_TICK_EN

        }
        else
        {

             kPend( RK_WAIT_FOREVER);

        }
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="imageblock data-line-2700">
<div class="content">
<img src="images/images/streamqueue.png" alt="streamqueue" width="30%">
</div>
</div>
</div>
</div>
<div class="sect3 data-line-2704">
<h4 id="summing_up_stream_queues_vs_mail_queues">3.8.3. Summing Up: Stream Queues vs Mail Queues</h4>
<div class="paragraph data-line-2706">
<p>While both are Message Queues, they are distinct designs that lead to distinct ideal use cases. Note that Mail Queues are particularly difficult to generalise.</p>
</div>
<table class="tableblock frame-all grid-all stretch data-line-2709">
<colgroup>
<col style="width: 30%;">
<col style="width: 35%;">
<col style="width: 35%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Feature</th>
<th class="tableblock halign-left valign-top">Mail Queue (Pointer-Based)</th>
<th class="tableblock halign-left valign-top">Stream Queue (Deep Copy-Based)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Storage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stores <strong>pointers</strong> to messages</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Stores <strong>deep copies</strong> of messages</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Message Size</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Either pointer-sized or can vary for each message.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Fixed (defined at queue initialisation)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Memory Management</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Internal pre-allocated (1 pointer/message). Might need a second storage.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Internal (pre-allocated buffer, N-words/message).</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Ownership</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Sender/receiver manage lifecycle</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kernel.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Performance</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A 'zero-copy' transmission is faster.</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Deterministic. Kernel Optimised deep-copy.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Best Use Cases</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Work Queues, Client-Server with dynamic payload, any case where zero-copy or 1-copy is feasible</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Real-time data streaming (e.g., sensor pipelines, inter-device communication).</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2 data-line-2720">
<h3 id="message_passing_ownership">3.9. Message Passing ownership</h3>
<div class="admonitionblock tip data-line-2723">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-2724">
<p>Priority Inversion happens on Message-Passing for similar but subtle different reasons from resource sharing.</p>
</div>
<div class="paragraph data-line-2726">
<p><em>Design Choice</em>: add an ownership mechanism for a message passing object&#8201;&#8212;&#8201;a well-defined receiver, so priority propagation can be applied.</p>
</div>
<div class="paragraph data-line-2728">
<p>Benefit: This preserves strict real-time guarantees, making sure a high-priority task never waits indefinitely for a lower-priority task to finish message operations</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2731">
<p>Using queues to communicate between multiple tasks is chaos. Many senders to many receivers ends up unpredictable. We often want N:1 (senders:receiver, N can be 1). This <em>1</em> makes it easier to reason on the dynamics.</p>
</div>
<div class="paragraph data-line-2733">
<p>On real-time design, we often expect to see blocking <em>send()</em> operations, on 1:1 or N:1 channels - a blocking <em>send()</em> on a 1:N (broadcast) would be very odd.</p>
</div>
<div class="sect3 data-line-2735">
<h4 id="priority_inversion_on_message_passing">3.9.1. Priority Inversion on Message Passing</h4>
<div class="paragraph data-line-2737">
<p>While sharing some similarities, there are subtle differences on blocking on a shared-resource (by blocking on a locked mutex), and blocking on a message passing object.</p>
</div>
<div class="paragraph data-line-2739">
<p><em>Assuming cases we do not want messages to be overwritten</em>, a sender when accessing a queue is acquiring an empty buffer. A receiver is acquiring a full buffer. They are competing for the same object but on different states. Thus, they depend on each other to change the object state.</p>
</div>
<div class="paragraph data-line-2742">
<p>When a sender blocks on a full shared message object, it does not mean there is another writer using the resource; By design it is also unlikely there is a reader blocked on the waiting queue of the object, since every time a write operation completes, any reader blocked on the queue is readied. Whether it is dispatched or not is a scheduler concern. If its priority is higher than the task that has just finished, it will be immediately dispatched. If not, it is enqueued on the ready queue until it is eventually picked.</p>
</div>
<div class="admonitionblock tip data-line-2745">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
This means the problem of priority inversion arises from waiting for the consumer rather than from direct contention among multiple senders.
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2747">
<p>So if the sender priority is higher, maybe it could be propagated to the reader. But, <em>which</em> reader? (This is the reason semaphores cannot implement priority inheritance protocol&#8201;&#8212;&#8201;the waiter task cannot a know potential signaller).</p>
</div>
<div class="paragraph data-line-2749">
<p>With that in mind, there is the option to set <em>ownership</em>: <code>setowner(mesgpass, taskhandle)</code>. From now own, only the owner task can receive from that service object&#8201;&#8212;&#8201;a blocking <code>send()</code> knows the the target task and can raise its priority.</p>
</div>
<div class="paragraph data-line-2751">
<p>(As 1:N communication normally non-blocking on real-time systems, there is no mechanism to establish 'sender ownership'.)</p>
</div>
<div class="paragraph data-line-2753">
<p>If other task that not the owner tries to receive from a kernel message-passing object that has an owner, it fails.</p>
</div>
<div class="paragraph data-line-2755">
<p>These kernel objects now will <em>resemble an aspect of Ports</em> - a common way of representing tasks on <em>message-passsing kernels</em>. (Strictly they are not Ports,  as RK0 is not a message-passing kernel - although I do like the approach.)</p>
</div>
</div>
</div>
<div class="sect2 data-line-2760">
<h3 id="most_recent_message_protocol_mrm">3.10. Most-Recent Message Protocol (MRM)</h3>
<table class="tableblock frame-all grid-all stretch data-line-2763">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">MRM Control Block</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MRM Buffer Allocator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Buffer Allocator</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Current MRM Buffer Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Size (Message Size)</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch data-line-2772">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">MRM Buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Data Buffer Address</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Readers Count</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all stretch data-line-2780">
<colgroup>
<col style="width: 100%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Data Buffer</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>Application-dependent</em></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip data-line-2786">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph data-line-2787">
<p>There is not much of a practical difference between a message that does not arrive and one with no useful (stale) data. But when wrong (or stale) data is processed - e.g., to define a set point on a loop - a system can fail badly.</p>
</div>
<div class="paragraph data-line-2789">
<p>Design Choice: provide a broadcast asynchronous message-passing scheme that guarantees data freshness and integrity for all readers.</p>
</div>
<div class="paragraph data-line-2791">
<p>Benefits: The system has a mechanism to meet strict deadlines that cannot be predicted on design time.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph data-line-2794">
<p>Control loops reacting to unpredictable time events - like a robot scanning an environment or a drive-by-wire system - require a different message-passing approach - readers cannot "look at the past" and cannot block. The most recent data must be delivered lock-free and have guaranteed integrity.</p>
</div>
<div class="sect3 data-line-2796">
<h4 id="functional_description">3.10.1. Functional Description</h4>
<div class="paragraph data-line-2798">
<p>An <em>MRM</em> works as a <em>1-to-many asynchronous Mailbox</em> - with a lock-free specialisation that enables several readers to get the most recent deposited message with no integrity issues. Whenever a reader reads an MRM buffer, it will find the most recent data transmitted.</p>
</div>
<div class="paragraph data-line-2800">
<p>The core idea on he MRM protocol is that readers can only access the buffer that is classified as the '<em>the most recent buffer</em>'. After a writer <em>publish()</em> a message, that will be the only message readers can <em>get()</em>&#8201;&#8212;&#8201;any former message being processed by a reader, was grabbed <em>before</em> a new <em>publish()</em> - and, from now on can only be <em>unget()</em>, eventually returning to the pool.</p>
</div>
<div class="paragraph data-line-2802">
<p>To clarify further, the communication steps are listed:</p>
</div>
<div class="olist arabic data-line-2804">
<ol class="arabic">
<li class="data-line-2804">
<p>A producer first reserves an MRM Buffer - the reserved MRM Buffer is not available for reading until it is published.</p>
</li>
<li class="data-line-2806">
<p>A message buffer is allocated, filled and its address is within a MRM Buffer. The producer <em>publishes</em> the message. From now on, it is <em>the most recent message</em>. Any former published buffer is no longer visibile for new readers</p>
</li>
<li class="data-line-2808">
<p>A reader starts by <em>getting</em> an MRM Buffer.  A <code>get()</code> operation delivers a copy of the message to the reader&#8217;s scope. Importantly, this operation increases the number of readers associated to that MRM Buffer.</p>
</li>
<li class="data-line-2810">
<p>Before ending its cycle, the task releases (<code>unget()</code>) the buffer; on releasing, the kernel checks if the caller task <em>is the last reader</em>, <em>and</em> if it the buffer being released is <em>not the current MRM Buffer</em>.</p>
</li>
<li class="data-line-2812">
<p>If the above conditions are met, the <code>unget()</code> operation will return the MRM buffer to the pool. If there are more readers <em>OR</em> it is the current buffer, it remains as available.</p>
</li>
<li class="data-line-2814">
<p>When <code>reserve</code> operation detects the most recent buffer still has readers - a new buffer is allocated to be written and published. If it has no readers, it is reused.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2816">
<p>This way, the worst case is a sequence of <code>publish()</code> with no <code>unget()</code> at all&#8201;&#8212;&#8201;this would lead to the writer finding no buffer to reserve. This is prevented by making: <code>N Buffers = N tasks + 1</code>.</p>
</div>
</div>
<div class="sect3 data-line-2818">
<h4 id="mrm_control_block_configuration">3.10.2. MRM Control Block Configuration</h4>
<div class="paragraph data-line-2821">
<p>What might lead to some confusion when initialising an MRM Control Block is the need for two different pools:</p>
</div>
<div class="ulist data-line-2823">
<ul>
<li class="data-line-2823">
<p>One pool will be the storage for the MRM Buffers - the data structure for the mechanism.</p>
</li>
<li class="data-line-2825">
<p>Another pool is for the actual payload. The messages.</p>
</li>
<li class="data-line-2827">
<p>Both pools <em>must</em> have the same number of elements: the number of tasks communicating + 1.</p>
</li>
<li class="data-line-2829">
<p>The size of the data buffers is application-dependent - and is passed as a number of <em>words</em>. The minimal message size is 32-bit.</p>
</li>
<li class="data-line-2831">
<p>If using data structures, keep it aligned to 4 to take advantage of the performance of aligned memory.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-2834">
<h4 id="usage_example">3.10.3. Usage Example</h4>
<div class="paragraph data-line-2836">
<p>Consider a modern car - speed variations are of interest in many modules. With a somehow "naive" approach, let us consider three modules and how they should react when speed varies:</p>
</div>
<div class="olist arabic data-line-2838">
<ol class="arabic">
<li class="data-line-2838">
<p><strong>Cruiser Control:</strong> For the Cruiser Control, a speed increase might signify the driver wants manual control back, and it will likely turn off.</p>
</li>
<li class="data-line-2840">
<p><strong>Windshield Wipers:</strong> If they are on, a speed change can reflect on the electric motor&#8217;s adjustments to the air resistance.</p>
</li>
<li class="data-line-2842">
<p><strong>Radio:</strong> Speed changes reflect the aerodynamic noise - the radio volume might need adjustment.</p>
</li>
</ol>
</div>
<div class="paragraph data-line-2844">
<p>As the variations are unpredictable, we need a mechanism to deliver the last speed in order of importance for all these modules. From highest to lowest priority, Cruise, Whipers, and Radio are the three modules that range from safety to comfort.</p>
</div>
<div class="paragraph data-line-2846">
<p>To emulate this scenario, we can write an application with a higher priority task that sleeps and wakes up at pseudo-random times to produce random values that represent the (unpredictable) speed changes.</p>
</div>
<div class="paragraph data-line-2848">
<p>The snippet below has 4 periodic tasks. Tasks are sleeping for absolute periods. The producer has a random interval of publishing new data, so it can either interrupt before one has the chance to finish or be inactive while they run more than once.</p>
</div>
<div class="exampleblock data-line-2850">
<div class="content">
<div class="listingblock data-line-2852">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">typedef struct
{
	UINT 	speed;
	RK_TICK timeStamp;
} Mesg_t;

#define N_MRM (5)  /* Number of MRMs N Tasks + 1 */
#define MRM_MESG_SIZE (sizeof(Mesg_t)/4) /* In WORDS */
RK_MRM MRMCtl;/* MRM control block */
RK_MRM_BUF buf[N_MRM];/* MRM pool */
Mesg_t data[N_MRM];/* message data pool */


VOID kApplicationInit( VOID)
{
	kCreateTask(&amp;speedSensorHandle, SpeedSensorTask, RK_NO_ARGS, "SpeedTsk", stack1, STACKSIZE, 1, RK_PREEMPT);
	kCreateTask(&amp;cruiserHandle, CruiserTask, RK_NO_ARGS, "CruiserTsk", stack2, STACKSIZE, 2, RK_PREEMPT);
	kCreateTask(&amp;wiperHandle, WiperTask, RK_NO_ARGS, "WiperTsk", stack3, STACKSIZE, 3, RK_PREEMPT);
	kCreateTask(&amp;radioHandle, RadioTask, RK_NO_ARGS, "RadioTsk", stack4, STACKSIZE, 4, RK_PREEMPT);
    kMRMInit( &amp;MRMCtl, buf, data, N_MRM, MRM_MESG_SIZE);
 }

VOID SpeedSensorTask( VOID *args)
{
    RK_UNUSEARGS

	Mesg_t sendMesg = {0};
	while (1)
    {
        RK_TICK currTick = kTickGet();
        UINT speedValue = (UINT) (rand() % 170) + 1;
		sendMesg.speed = speedValue;
		sendMesg.timeStamp = currTick;
		/* grab a buffer */
        RK_MRM_BUF *bufPtr =  kMRMReserve( &amp;MRMCtl);
        if (bufPtr != NULL)
        {
            kMRMPublish( &amp;MRMCtl, bufPtr,  &amp;sendMesg);
        }
        else
        {/* cannot fail */
            kassert( 0);
        }
/* publish  */
         printf( "! @ %dT: SPEED UPDATE: %u \r\n", currTick, speedValue);
		RK_TICK sleepTicks = (( RK_TICK) rand() % 15) + 1;
        kSleepUntil( sleepTicks);
	}
}

VOID CruiserTask( VOID *args)
{
    RK_UNUSEARGS

	Mesg_t recvMesg = {0};
    while (1)
    {
        RK_MRM_BUF *readBufPtr = kMRMGet( &amp;MRMCtl,  &amp;recvMesg);
		printf( "@ %dT CRUISER: (%u, %uT) \r\n", kTickGet(), recvMesg.speed, recvMesg.timeStamp);
 		kMRMUnget( &amp;MRMCtl, readBufPtr);
		kSleepUntil( 4);

    }
}


VOID WiperTask( VOID *args)
{
    RK_UNUSEARGS
	Mesg_t recvMesg = {0};

    while (1)
    {

        RK_MRM_BUF *readBufPtr = kMRMGet( &amp;MRMCtl,  &amp;recvMesg);
		printf( "@ %dT WIPERS: (%u, %uT) \r\n", kTickGet(), recvMesg.speed, recvMesg.timeStamp);
 		kMRMUnget( &amp;MRMCtl, readBufPtr);
		kSleepUntil( 8);


    }
}
VOID RadioTask( VOID *args)
{
    RK_UNUSEARGS
	Mesg_t recvMesg = {0};

    while (1)

    {
        RK_MRM_BUF *readBufPtr = kMRMGet( &amp;MRMCtl, &amp;recvMesg);
		printf( "@ %dT RADIO: (%u, %uT) \r\n", kTickGet(), recvMesg.speed, recvMesg.timeStamp);
 		kMRMUnget( &amp;MRMCtl, readBufPtr);
 		kSleepUntil(12);

    }

}</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph data-line-2956">
<p>Thus, different situations can happen:</p>
</div>
<div class="ulist data-line-2958">
<ul>
<li class="data-line-2958">
<p>All tasks read the updated pair (speed, time)</p>
</li>
<li class="data-line-2959">
<p>Not all tasks receive the updated pair because another update happens in between.</p>
</li>
<li class="data-line-2960">
<p>No tasks receive an update - because another happens too soon.</p>
</li>
<li class="data-line-2961">
<p>All tasks receive an update and will keep rereading the same values.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-2963">
<p>All these cases are on the image:</p>
</div>
<div class="imageblock data-line-2965">
<div class="content">
<img src="images/images/pumpdrop.png" alt="pumpdrop" width="30%">
</div>
</div>
<div class="admonitionblock tip data-line-2968">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<em>The highlight is that controllers are being able to keep their pace, while receiving fresh data - you can see it on the timestamp on the image.</em> Again, they might receive the same data more than once, or miss samples, what is important is that <em>they are not lagging and consuming stale data.</em>
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-2970">
<h2 id="error_handling">4. <em><strong>Error Handling</strong></em></h2>
<div class="sectionbody">
<div class="paragraph data-line-2972">
<p>While tracing and error handling are yet to be largely improved (and that is when the 1.0.0 version will be released), currently
<em>RK0</em> employs a policy of <em>failing fast</em> in <strong>debug mode</strong>.</p>
</div>
<div class="paragraph data-line-2975">
<p>A central error handler function <code>kErrHandler()</code> is invoked whenever a fatal error (such as a stack overflow, null pointer, or internal inconsistency, violated invariant, etc.).</p>
</div>
<div class="paragraph data-line-2977">
<p>The error handler’s job is to halt or safely transition the system. In the default implementation, <code>kErrHandler</code> disable interrupts, stopping execution so the condition can be observed during debugging. A fault code is stored the global <code>faultID</code>.</p>
</div>
<div class="paragraph data-line-2979">
<p>A trace structure records the address of the running TCB, its current stack pointer, the link register (that is, the PC at kErrHandler was called) and a time-stamp.</p>
</div>
<div class="paragraph data-line-2981">
<p>Developers can hook in custom behaviour&#8201;&#8212;&#8201;an application-dependent recover strategy. This record is on a <code>.noinit</code> RAM section, so it is visible if ever resetting the CPU.</p>
</div>
<div class="paragraph data-line-2983">
<p>Operations that are clearly an application design error, such as operating on a object that was not initialised, a blocking call from an ISR, dereferencing null pointers, etc., will hard fault.
Anyway, one must always be checking for return values.</p>
</div>
<div class="paragraph data-line-2986">
<p><em>PS: Some deeper internal calls are simply being asserted - as they are not supposed to fail despite the user inputs.</em></p>
</div>
<div class="paragraph data-line-2990">
<div class="title">Stack Overflow</div>
<p>Stack overflow is detected (not prevented), using a "stack painting" with a sentinel word.</p>
</div>
<div class="paragraph data-line-2992">
<p>One can take advantage of the static task model - <em>it is possible to predict offline</em> the deepest call within any task.  The -fstack-usage compiler flag, will create <code>.su</code> files indicating the depth of every function within a module. This is an example for the synchronisation compilation unit with all features enabled:</p>
</div>
<div class="listingblock data-line-2994">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">core/src/ksynch.c:61:8:kSignalGet	112	static
core/src/ksynch.c:163:8:kSignalSet	72	static
core/src/ksynch.c:214:8:kSignalClear	40	static
core/src/ksynch.c:237:8:kSignalQuery	56	static
core/src/ksynch.c:260:8:kEventInit	40	static
core/src/ksynch.c:279:8:kEventSleep	112	static
core/src/ksynch.c:343:8:kEventWake	88	static
core/src/ksynch.c:383:8:kEventSignal	64	static
core/src/ksynch.c:412:7:kEventQuery	16	static
core/src/ksynch.c:429:8:kSemaInit	88	static
core/src/ksynch.c:470:8:kSemaPend	96	static
core/src/ksynch.c:555:8:kSemaPost	88	static
core/src/ksynch.c:603:8:kSemaWake	72	static
core/src/ksynch.c:640:5:kSemaQuery	40	static
core/src/ksynch.c:662:8:kMutexInit	16	static
core/src/ksynch.c:681:8:kMutexLock	120	static
core/src/ksynch.c:761:8:kMutexUnlock	96	static
core/src/ksynch.c:834:6:kMutexQuery	56	static</code></pre>
</div>
</div>
<div class="paragraph data-line-3015">
<p>These are the worst cases. Now, you identify the depth of the longest <em>chain of calls</em> for a task using these services, and add a generous safety margin&#8201;&#8212;&#8201;no less than 30%. The cap depends on your budget.</p>
</div>
<div class="paragraph data-line-3017">
<p>Importantly, you also have to size the System Stack. This initial size is defined on <code>linker.ld</code>, on the symbol <code>Min_Stack_Size</code>. In this case you need to account for the depth of <code>main()</code>, <code>kApplicationInit()</code> and all interrupt handlers&#8201;&#8212;&#8201;again, inspect the the longest call chain depth. Assume interrupts will always add to the worst static depth, and make sure to account for <em>nested interrupts</em>. Do it judiciously.</p>
</div>
<div class="paragraph data-line-3021">
<div class="title">Deadlocks</div>
<p>There are deadlock recovering mechanisms on the literature, a pitty they are unfeasible here. The kernel provides bounded waiting, enforces every waiting queue to priority discipline and applies priority inheritance on mutexes and message passing. Besides, it provides lock free primitives and compensates for time drifting if enforcing a period on tasks. It is something.</p>
</div>
<div class="paragraph data-line-3023">
<p>For those programming the application, despite following the RMS rule of higher priority for higher request rate tasks, the golden rule for locking is acquiring resources on an unidirectional order <em>throughout the entire application</em>:</p>
</div>
<div class="listingblock data-line-3024">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">acquire(A);
acquire(B);
acquire(C);
   .
   .
   .
release(C);
release(B);
release(A);</code></pre>
</div>
</div>
<div class="paragraph data-line-3040">
<p>This breaks circular waitings.</p>
</div>
<div class="paragraph data-line-3042">
<p>For instance:</p>
</div>
<div class="listingblock data-line-3044">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">TaskA:
   wait(R1);
   wait(R2);
    /* critical section */
   signal(R2);
   signal(R1);

TaskB:
   wait(R1);
   wait(R2);
    /* critical section */
   signal(R2);
   signal(R1);</code></pre>
</div>
</div>
<div class="paragraph data-line-3062">
<p>But, if:</p>
</div>
<div class="listingblock data-line-3064">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">TaskA:
    wait(R1);
    wait(R2);
    .
    .

TaskB:
    wait(R2);
    wait(R1);
    .
    .</code></pre>
</div>
</div>
<div class="paragraph data-line-3078">
<p>There are some possible outcomes:</p>
</div>
<div class="olist arabic data-line-3080">
<ol class="arabic">
<li class="data-line-3080">
<p>Deadlock:</p>
<div class="ulist data-line-3082">
<ul>
<li class="data-line-3082">
<p>TaskA runs: acquires R1</p>
</li>
<li class="data-line-3083">
<p>TaskB runs: acquires R2</p>
</li>
<li class="data-line-3084">
<p>TaskA runs: tries to acquire R2 — blocked</p>
</li>
<li class="data-line-3085">
<p>TaskB runs: tries to acquire R1 — blocked</p>
</li>
</ul>
</div>
</li>
<li class="data-line-3087">
<p>No deadlock:</p>
<div class="ulist data-line-3089">
<ul>
<li class="data-line-3089">
<p>TaskA runs: acquires R1</p>
</li>
<li class="data-line-3091">
<p>TaskA runs: acquires R2 (nobody is holding R2)</p>
</li>
<li class="data-line-3093">
<p>TaskA releases both; TaskB runs and acquires both (in either order)</p>
</li>
</ul>
</div>
</li>
</ol>
</div>
<div class="paragraph data-line-3096">
<p>Overall, if tasks do not overlap on critical sections, there is no deadlock. That is why systems run for years with no deadlocks and eventually: <em>ploft</em>.</p>
</div>
</div>
</div>
<div class="sect1 data-line-3099">
<h2 id="rk0_services_api">5. <em><strong>RK0 Services API</strong></em></h2>
<div class="sectionbody">
<div class="paragraph data-line-3101">
<p>This section provides a description of the kernel service calls.</p>
</div>
<div class="ulist data-line-3105">
<div class="title">Overall Convention</div>
<ul>
<li class="data-line-3105">
<p>A kernel call starts with a lower-case 'k. Typically it is followed by a kernel object identifier, and an action.</p>
</li>
</ul>
</div>
<div class="listingblock data-line-3107">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">kSemaPend(&amp;sema, 800); /* pend on a semaphore; 800 ticks time-out */</code></pre>
</div>
</div>
<div class="ulist data-line-3111">
<ul>
<li class="data-line-3111">
<p>When <code>k</code> is followed by an action, it means it is acting on the caller task.</p>
</li>
</ul>
</div>
<div class="listingblock data-line-3113">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">kSleep(150); /* sleep-delay the caller task for 150 ticks */</code></pre>
</div>
</div>
<div class="ulist data-line-3117">
<ul>
<li class="data-line-3117">
<p>Some functions that can act either on the caller or on another task - in these cases a special value might be passed to make the intention explicit:</p>
</li>
</ul>
</div>
<div class="listingblock data-line-3119">
<div class="content">
<pre class="highlightjs highlight"><code class="language-C hljs" data-lang="C">/* stores the signal flags of the task identified by task1Handle on queryValue */
kSignalQuery(task1Handle, &amp;queryValue);

/* the NULL is telling to act on the caller: retrieves its own signal flags */
kSignalQuery(NULL, &amp;queryValue);</code></pre>
</div>
</div>
<div class="paragraph data-line-3128">
<p>With a few exceptions, kernel calls return a <code>RK_ERR</code> error code. <code>0</code> is a successful operation <code>(RK_SUCCCESS)</code> and any negative value is a error. These error codes are defined in <code>kcommondefs.h</code>.</p>
</div>
<div class="sect2 data-line-3131">
<h3 id="task_management">5.1. Task Management</h3>
<div class="sect3 data-line-3133">
<h4 id="kcreatetask">5.1.1. kCreateTask</h4>
<div class="paragraph data-line-3136">
<div class="title">Description</div>
<p>Assemble a declared task.</p>
</div>
<div class="listingblock data-line-3140">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kCreateTask( RK_TASK_HANDLE *taskHandlePtr,
		const RK_TASKENTRY taskFunc, VOID *argsPtr,
		CHAR *const taskName, RK_STACK *const stackAddrPtr,
		const UINT stackSize, const RK_PRIO priority,
		const BOOL preempt);</code></pre>
</div>
</div>
<div class="ulist data-line-3152">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3152">
<p><strong>taskHandlePtr</strong>:: Pointer to the Handle object for the task.</p>
</li>
<li class="data-line-3153">
<p><strong>taskFunc</strong>:: Task&#8217;s entry function. Prototype: <code>VOID taskFunc(VOID *)</code></p>
</li>
<li class="data-line-3154">
<p><strong>argsPtr</strong>:: Pointer to initial task arguments. (opt. <code>RK_NO_ARGS</code>)</p>
</li>
<li class="data-line-3155">
<p><strong>taskName</strong>:: Task name (up to 8 bytes, configured at <code>RK_NAME</code> macro).</p>
</li>
<li class="data-line-3156">
<p><strong>stackAddr</strong>:: Pointer to the task stack (the array&#8217;s name).</p>
</li>
<li class="data-line-3157">
<p><strong>stackSize</strong>:: Size of the task stack (in WORDS; 1 WORD = 4 BYTES).</p>
</li>
<li class="data-line-3159">
<p><strong>priority</strong>:: Task priority, valid range: 0-31.</p>
</li>
<li class="data-line-3160">
<p><strong>preempt</strong>:: Values: <code>RK_PREEMPT / RK_NO_PREEMPT</code>. If <code>RK_NO_PREEMPT</code>, the task once dispatched is not preempted by user tasks until READY/WAITING state. Still it can be preempted by hardware/interrupts, and then resumed.
Used for tasks like deferred ISR handlers. They are supposed to be exceptional.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3164">
<h4 id="kinit">5.1.2. kInit</h4>
<div class="paragraph data-line-3167">
<div class="title">Description</div>
<p>Initialises the kernel. To be called in main() after hardware initialisation.</p>
</div>
<div class="listingblock data-line-3171">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VOID kInit(VOID);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3175">
<h4 id="kyield">5.1.3. kYield</h4>
<div class="paragraph data-line-3178">
<div class="title">Description</div>
<p>The current task yields the processor. Essential when round-robin between tasks with the same priority if there no other blocking calls.</p>
</div>
<div class="listingblock data-line-3182">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VOID kYield(VOID);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3187">
<h4 id="kschlock">5.1.4. kSchLock</h4>
<div class="paragraph data-line-3190">
<div class="title">Description</div>
<p>Disables preemption for the current task until <code>kSchUnlock()</code> is issued.</p>
</div>
<div class="listingblock data-line-3194">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VOID kSchLock(VOID);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3198">
<h4 id="kschunlock">5.1.5. kSchUnlock</h4>
<div class="paragraph data-line-3201">
<div class="title">Description</div>
<p>Restore preemption status. To be called at the end of the operation guarded by <code>kSchLock()</code>.</p>
</div>
<div class="listingblock data-line-3205">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VOID kSchUnlock(VOID);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-3211">
<h3 id="signals">5.2. Signals</h3>
<div class="sect3 data-line-3213">
<h4 id="ksignalget">5.2.1. kSignalGet</h4>
<div class="paragraph data-line-3215">
<p>A task pends on its own event flags.</p>
</div>
<div class="listingblock data-line-3219">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSignalGet(ULONG const required,
                  UINT const options,
                  ULONG *const gotFlagsPtr,
                  RK_TICK const timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3227">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3227">
<p><strong>required</strong>:: Combination of required flags (bitstring, non-zero).</p>
</li>
<li class="data-line-3228">
<p><strong>options</strong>:: RK_FLAGS_ANY or RK_FLAGS_ALL.</p>
</li>
<li class="data-line-3229">
<p><strong>gotFlagsPtr</strong>:: Pointer to store returned flags (optional, NULL allowed).</p>
</li>
<li class="data-line-3230">
<p><strong>timeout</strong>:: Suspension timeout if required flags are not met.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3233">
<div class="title">Returns</div>
<p>RK_SUCCESS, RK_ERR_FLAGS_NOT_MET, or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3237">
<h4 id="ksignalset">5.2.2. kSignalSet</h4>
<div class="paragraph data-line-3239">
<p>Posts a combination of flags to a task.</p>
</div>
<div class="listingblock data-line-3244">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSignalSet(RK_TASK_HANDLE const taskHandle, ULONG const mask);</code></pre>
</div>
</div>
<div class="ulist data-line-3249">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3249">
<p><strong>taskHandle</strong>:: Receiver Task handle.</p>
</li>
<li class="data-line-3250">
<p><strong>mask</strong>:: Bitmask to signal (non-zero).</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3253">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3256">
<h4 id="ksignalquery">5.2.3. kSignalQuery</h4>
<div class="paragraph data-line-3258">
<p>Retrieves a task&#8217;s signal flags.</p>
</div>
<div class="listingblock data-line-3262">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSignalQuery(RK_TASK_HANDLE const taskHandle, ULONG *const gotFlagsPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3267">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3267">
<p><strong>taskHandle</strong>:: Target task; use NULL if target is caller task.</p>
</li>
<li class="data-line-3268">
<p><strong>gotFlagsPtr</strong>:: Pointer to store current flags.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3271">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3275">
<h4 id="ksignalclear">5.2.4. kSignalClear</h4>
<div class="paragraph data-line-3277">
<p>Clears the caller task flags.</p>
</div>
<div class="listingblock data-line-3281">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSignalClear(VOID);</code></pre>
</div>
</div>
<div class="paragraph data-line-3287">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
</div>
<div class="sect2 data-line-3290">
<h3 id="events_sleep_queues">5.3. Events (Sleep Queues)</h3>
<div class="sect3 data-line-3292">
<h4 id="keventinit">5.3.1. kEventInit</h4>
<div class="paragraph data-line-3294">
<p>Initialises an event object.</p>
</div>
<div class="listingblock data-line-3298">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kEventInit(RK_EVENT *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-3303">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3303">
<p><strong>kobj</strong>:: Pointer to RK_EVENT object.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3306">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3310">
<h4 id="keventsleep">5.3.2. kEventSleep</h4>
<div class="paragraph data-line-3312">
<p>Suspends a task waiting for a wake signal.</p>
</div>
<div class="listingblock data-line-3316">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kEventSleep(RK_EVENT *const kobj, const RK_TICK timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3322">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3322">
<p><strong>kobj</strong>:: Pointer to RK_EVENT object.</p>
</li>
<li class="data-line-3323">
<p><strong>timeout</strong>:: Suspension time.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3326">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3329">
<h4 id="keventwake">5.3.3. kEventWake</h4>
<div class="paragraph data-line-3331">
<p>Broadcast signal for an event.</p>
</div>
<div class="listingblock data-line-3335">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kEventWake(RK_EVENT *const kobj, UINT nTasks, UINT *uTasksPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3340">
<div class="title">Parameters*</div>
<ul>
<li class="data-line-3340">
<p><strong>kobj</strong>:: Event address.</p>
</li>
<li class="data-line-3341">
<p><strong>nTasks</strong>:: Number of tasks to wake (0 = all).</p>
</li>
<li class="data-line-3342">
<p><strong>uTasksPtr</strong>:: (Optional) Pointer to store number of unreleased tasks, if any.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3345">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
<div class="paragraph data-line-3350">
<div class="title">Helper</div>
<p>Wakes all tasks.</p>
</div>
<div class="listingblock data-line-3352">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kEventFlush(RK_EVENT *const kobj);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3356">
<h4 id="keventsignal">5.3.4. kEventSignal</h4>
<div class="paragraph data-line-3358">
<p>Wakes a single task sleeping for a specific event (by priority).</p>
</div>
<div class="listingblock data-line-3362">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kEventSignal(RK_EVENT *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-3367">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3367">
<p><strong>kobj</strong>:: Pointer to RK_EVENT object.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3370">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3372">
<h4 id="keventquery">5.3.5. kEventQuery</h4>
<div class="paragraph data-line-3375">
<div class="title">Description</div>
<p>Retrieves the number of tasks sleeping on an event.</p>
</div>
<div class="listingblock data-line-3379">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kEventQuery( RK_EVENT const * const kobj, ULONG *const nTasksPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3384">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3384">
<p><strong>kobj</strong>:: Pointer to RK_EVENT object.</p>
</li>
<li class="data-line-3385">
<p><strong>nTasksPtr</strong>:: Pointer to store the retrieved number of tasks.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-3387">
<h3 id="semaphores_countingbinary">5.4. Semaphores (Counting/Binary)</h3>
<div class="sect3 data-line-3390">
<h4 id="ksemainit">5.4.1. kSemaInit</h4>
<div class="paragraph data-line-3392">
<p>Initialises a semaphore.</p>
</div>
<div class="listingblock data-line-3396">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaInit(RK_SEMA *const kobj, UINT const semaType, const UINT value);</code></pre>
</div>
</div>
<div class="listingblock data-line-3402">
<div class="title">Helpers</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaCountInit(RK_SEMA *const kobj, const UINT value);

RK_ERR kSemaBinInit(RK_SEMA *const kobj, const UINT value);</code></pre>
</div>
</div>
<div class="ulist data-line-3410">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3410">
<p><strong>kobj</strong>:: Semaphore address.</p>
</li>
<li class="data-line-3411">
<p><strong>semaType</strong>:: Counting(RK_SEMA_COUNT) or Binary (RK_SEMA_BIN).</p>
</li>
<li class="data-line-3412">
<p><strong>value</strong>:: Initial value (&gt;= 0).</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3415">
<h4 id="ksemapend">5.4.2. kSemaPend</h4>
<div class="paragraph data-line-3417">
<p>Waits on a semaphore.</p>
</div>
<div class="listingblock data-line-3421">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaPend(RK_SEMA *const kobj, const RK_TICK timeout);</code></pre>
</div>
</div>
<div class="listingblock data-line-3427">
<div class="title">Alias</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaWait(RK_SEMA *const kobj, const RK_TICK timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3432">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3432">
<p><strong>kobj</strong>:: Semaphore address.</p>
</li>
<li class="data-line-3433">
<p><strong>timeout</strong>:: Maximum suspension time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3436">
<h4 id="ksemapost">5.4.3. kSemaPost</h4>
<div class="paragraph data-line-3438">
<p>Signals a semaphore.</p>
</div>
<div class="listingblock data-line-3442">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaPost(RK_SEMA *const kobj);</code></pre>
</div>
</div>
<div class="listingblock data-line-3448">
<div class="title">Alias</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaSignal(RK_SEMA *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-3454">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3454">
<p><strong>kobj</strong>:: Semaphore address.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3457">
<h4 id="ksemawake">5.4.4. kSemaWake</h4>
<div class="paragraph data-line-3459">
<p>Broadcast signal to a semaphore.</p>
</div>
<div class="listingblock data-line-3464">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaWake(RK_SEMA *const kobj, UINT nTasks, UINT *uTasksPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3469">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3469">
<p><strong>kobj</strong>:: Semaphore address.</p>
</li>
<li class="data-line-3470">
<p><strong>nTasks</strong>:: Number of tasks to wake (0 = all).</p>
</li>
<li class="data-line-3471">
<p><strong>uTasksPtr</strong>:: (Optional) Pointer to store number of unreleased tasks, if any.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3475">
<div class="title">Helper:</div>
<p>Wakes ALL tasks</p>
</div>
<div class="listingblock data-line-3477">
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaFlush(RK_SEMA *const kobj);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3483">
<h4 id="ksemaquery">5.4.5. kSemaQuery</h4>
<div class="paragraph data-line-3485">
<p>Retrieves the count value of a semaphore.
A negative value is the number of blocked tasks. A non-negative value is the semaphore&#8217;s counter number.</p>
</div>
<div class="listingblock data-line-3490">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSemaQuery(RK_SEMA const * const kobj, INT *const countPtr)</code></pre>
</div>
</div>
<div class="ulist data-line-3495">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3495">
<p><strong>kobj</strong>:: Semaphore address.</p>
</li>
<li class="data-line-3496">
<p><strong>countPtr</strong>:: Pointer to store the retrieved value.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-3499">
<h3 id="mutex_semaphore">5.5. Mutex Semaphore</h3>
<div class="sect3 data-line-3502">
<h4 id="kmutexinit">5.5.1. kMutexInit</h4>
<div class="paragraph data-line-3504">
<p>Initialises a mutex.</p>
</div>
<div class="listingblock data-line-3508">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMutexInit(RK_MUTEX *const kobj, UINT const prioInh);</code></pre>
</div>
</div>
<div class="ulist data-line-3513">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3513">
<p><strong>kobj</strong>:: Mutex address.</p>
</li>
<li class="data-line-3514">
<p><strong>prioInh</strong>:: Priority inheritance. <code>RK_INHERIT</code> / <code>RK_NO_INHERIT</code></p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3516">
<h4 id="kmutexlock">5.5.2. kMutexLock</h4>
<div class="paragraph data-line-3518">
<p>Locks a mutex.</p>
</div>
<div class="listingblock data-line-3522">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMutexLock(RK_MUTEX *const kobj, BOOL const prioInh, RK_TICK const timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3526">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3526">
<p><strong>kobj</strong>:: Mutex address.</p>
</li>
<li class="data-line-3527">
<p><strong>prioInh</strong>:: Apply priority inheritance (RK_INHERIT / RK_NO_INHERIT).</p>
</li>
<li class="data-line-3528">
<p><strong>timeout</strong>:: Maximum suspension time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3531">
<h4 id="kmutexunlock">5.5.3. kMutexUnlock</h4>
<div class="paragraph data-line-3533">
<p>Unlocks a mutex.</p>
</div>
<div class="listingblock data-line-3537">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMutexUnlock(RK_MUTEX *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-3544">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3544">
<p><strong>kobj</strong>:: Mutex address.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3547">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3550">
<h4 id="kmutexquery">5.5.4. kMutexQuery</h4>
<div class="paragraph data-line-3552">
<p>Retrieves the state of a mutex.</p>
</div>
<div class="listingblock data-line-3556">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMutexQuery( RK_MUTEX const *const kobj, UINT *const statePtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3561">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3561">
<p><strong>kobj</strong>:: Mutex address.</p>
</li>
<li class="data-line-3562">
<p><strong>statePtr</strong>:: Pointer to store the state (0 unlocked, 1 locked).</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-3565">
<h3 id="condition_variables_2">5.6. Condition Variables</h3>
<div class="paragraph data-line-3567">
<p>Helpers for managing Condition Variables using the <code>RK_EVENT</code> service .</p>
</div>
<div class="sect3 data-line-3570">
<h4 id="kcondvarwait">5.6.1. kCondVarWait</h4>
<div class="paragraph data-line-3572">
<p>After testing for a condition that returns false, this call unlocks
the associated mutex and task goes to sleep. When waking up, the task returns within the mutex critical region.</p>
</div>
<div class="listingblock data-line-3577">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kCondVarWait(RK_EVENT *const eventPtr, RK_MUTEX *const mutexPtr, RK_TICK timeout)</code></pre>
</div>
</div>
<div class="ulist data-line-3582">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3582">
<p><strong>eventPtr</strong>:: Event object composing the condition variable.</p>
</li>
<li class="data-line-3583">
<p><strong>mutexPtr</strong>:: Mutex that is locked for testing the condition.</p>
</li>
<li class="data-line-3584">
<p><strong>timeout</strong> :: Timeout for both waiting on event and locking on mutex.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3586">
<h4 id="kcondvarsignal">5.6.2. kCondVarSignal</h4>
<div class="paragraph data-line-3589">
<p>Same as <code>kEventSignal()</code>. Wakes a single task, the highest priority one.</p>
</div>
<div class="listingblock data-line-3593">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kCondVarSignal(RK_EVENT *const eventPtr)</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3597">
<h4 id="kcondvarbroadcast">5.6.3. kCondVarBroadcast</h4>
<div class="paragraph data-line-3600">
<p>Same as <code>kEventFlush()</code>. Wakes all sleeping tasks.</p>
</div>
<div class="listingblock data-line-3604">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kCondVarBroadcast(RK_EVENT *const eventPtr)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2 data-line-3610">
<h3 id="mailbox_2">5.7. Mailbox</h3>
<div class="sect3 data-line-3613">
<h4 id="kmboxinit">5.7.1. kMboxInit</h4>
<div class="paragraph data-line-3615">
<p>Initialises an indirect single mailbox.</p>
</div>
<div class="listingblock data-line-3620">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxInit(RK_MBOX *const kobj, VOID *const initMailPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3626">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3626">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3627">
<p><strong>initMailPtr</strong>:: Initial mail address if initialising full; else NULL.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3629">
<h4 id="kmboxsetowner">5.7.2. kMboxSetOwner</h4>
<div class="paragraph data-line-3631">
<p>Assigns a task owner for the mailbox.</p>
</div>
<div class="listingblock data-line-3635">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxSetOwner(RK_MBOX *const kobj, const RK_TASK_HANDLE taskHandle);</code></pre>
</div>
</div>
<div class="ulist data-line-3640">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3640">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3641">
<p><strong>taskHandle</strong>:: Task handle.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3643">
<h4 id="kmboxpost">5.7.3. kMboxPost</h4>
<div class="paragraph data-line-3645">
<p>Sends to a mailbox.</p>
</div>
<div class="listingblock data-line-3649">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxPost(RK_MBOX *const kobj, VOID *sendPtr, RK_TICK const timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3654">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3654">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3655">
<p><strong>sendPtr</strong>:: Mail address.</p>
</li>
<li class="data-line-3656">
<p><strong>timeout</strong>:: Suspension timeout.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3658">
<h4 id="kmboxpend">5.7.4. kMboxPend</h4>
<div class="paragraph data-line-3660">
<p>Receives from a mailbox.</p>
</div>
<div class="ulist data-line-3663">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3663">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3664">
<p><strong>recvPPtr</strong>:: Pointer to store message address (pointer-to-pointer).</p>
</li>
<li class="data-line-3665">
<p><strong>timeout</strong>:: Suspension timeout.</p>
</li>
</ul>
</div>
<div class="listingblock data-line-3669">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxPend(RK_MBOX *const kobj, VOID **recvPPtr, RK_TICK const timeout);</code></pre>
</div>
</div>
</div>
<div class="sect3 data-line-3673">
<h4 id="kmboxpeek">5.7.5. kMboxPeek</h4>
<div class="paragraph data-line-3676">
<div class="title">Description</div>
<p>Reads the mail without extracting it.</p>
</div>
<div class="listingblock data-line-3680">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxPeek(RK_MBOX *const kobj, VOID **peekPPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3686">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3686">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3687">
<p><strong>peekPPtr</strong>:: Pointer to receive mail address.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3689">
<h4 id="kmboxquery">5.7.6. kMboxQuery</h4>
<div class="paragraph data-line-3692">
<div class="title">Description</div>
<p>Retrieves the state of a mailbox.</p>
</div>
<div class="listingblock data-line-3696">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxQuery( RK_MBOX const * const kobj, UINT *const statePtr)</code></pre>
</div>
</div>
<div class="ulist data-line-3702">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3702">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3703">
<p><strong>statePtr</strong>:: Pointer to store the state (1=FULL, 0=EMPTY)</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3707">
<h4 id="kmboxpostovw">5.7.7. kMboxPostOvw</h4>
<div class="paragraph data-line-3710">
<div class="title">Description</div>
<p>Posts to a mailbox overwriting current mail, if any.</p>
</div>
<div class="listingblock data-line-3714">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMboxPostOvw(RK_MBOX *const kobj, VOID *sendPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3719">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3719">
<p><strong>kobj</strong>:: Mailbox address.</p>
</li>
<li class="data-line-3720">
<p><strong>sendPtr</strong>:: Mail address.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-3723">
<h3 id="mail_queues">5.8. Mail Queues</h3>
<div class="sect3 data-line-3726">
<h4 id="kqueueinit">5.8.1. kQueueInit</h4>
<div class="paragraph data-line-3729">
<div class="title">Description</div>
<p>Initialises a mail queue.</p>
</div>
<div class="listingblock data-line-3733">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueueInit(RK_QUEUE *const kobj, VOID *bufPtr, const ULONG maxItems);</code></pre>
</div>
</div>
<div class="ulist data-line-3738">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3738">
<p><strong>kobj</strong>:: Mail Queue address.</p>
</li>
<li class="data-line-3739">
<p><strong>bufPtr</strong>:: Pointer to buffer storing mail addresses.</p>
</li>
<li class="data-line-3740">
<p><strong>maxItems</strong>:: Maximum number of mails.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3742">
<h4 id="kqueuesetowner">5.8.2. kQueueSetOwner</h4>
<div class="paragraph data-line-3746">
<div class="title">Description</div>
<p>Assigns a task owner for the queue.</p>
</div>
<div class="listingblock data-line-3751">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueueSetOwner(RK_QUEUE *const kobj, const RK_TASK_HANDLE taskHandle);</code></pre>
</div>
</div>
<div class="ulist data-line-3757">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3757">
<p><strong>kobj</strong>:: Mail Queue address.</p>
</li>
<li class="data-line-3758">
<p><strong>taskHandle</strong>:: Task handle.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-3761">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
<div class="sect3 data-line-3765">
<h4 id="kqueuepost">5.8.3. kQueuePost</h4>
<div class="paragraph data-line-3768">
<div class="title">Description</div>
<p>Sends to a mail queue.</p>
</div>
<div class="listingblock data-line-3773">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueuePost(RK_QUEUE *const kobj, VOID *sendPtr, RK_TICK const timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3780">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3780">
<p><strong>kobj</strong>:: Mail Queue address.</p>
</li>
<li class="data-line-3781">
<p><strong>sendPtr</strong>:: Mail address.</p>
</li>
<li class="data-line-3782">
<p><strong>timeout</strong>:: Suspension timeout.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3784">
<h4 id="kqueuepend">5.8.4. kQueuePend</h4>
<div class="paragraph data-line-3786">
<p>Receives from a mail queue.</p>
</div>
<div class="listingblock data-line-3790">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueuePend(RK_QUEUE *const kobj, VOID **recvPPtr, RK_TICK const timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3796">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3796">
<p><strong>kobj</strong>:: Mail Queue address.</p>
</li>
<li class="data-line-3797">
<p><strong>recvPPtr</strong>:: Pointer to store message address (pointer-to-pointer).</p>
</li>
<li class="data-line-3798">
<p><strong>timeout</strong>:: Suspension timeout.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3800">
<h4 id="kqueuepeek">5.8.5. kQueuePeek</h4>
<div class="paragraph data-line-3803">
<div class="title">Description</div>
<p>Reads the head mail without extracting.</p>
</div>
<div class="listingblock data-line-3808">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueuePeek(RK_QUEUE *const kobj, VOID **peekPPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3813">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3813">
<p><strong>kobj</strong>:: Mail Queue address.</p>
</li>
<li class="data-line-3814">
<p><strong>peekPPtr</strong>:: Pointer to receive address.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3816">
<h4 id="kqueuejam">5.8.6. kQueueJam</h4>
<div class="paragraph data-line-3820">
<div class="title">Description</div>
<p>Sends a message to the queue front.</p>
</div>
<div class="listingblock data-line-3824">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueueJam(RK_QUEUE *const kobj, VOID *sendPtr, RK_TICK const timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3829">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3829">
<p><strong>kobj</strong>:: Queue address.</p>
</li>
<li class="data-line-3830">
<p><strong>sendPtr</strong>:: Message address.</p>
</li>
<li class="data-line-3831">
<p><strong>timeout</strong>:: Suspension time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3835">
<h4 id="kqueuequery">5.8.7. kQueueQuery</h4>
<div class="paragraph data-line-3838">
<div class="title">Description</div>
<p>Retrieves number of mails within queue.</p>
</div>
<div class="listingblock data-line-3842">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kQueueQuery(RK_QUEUE const * const kobj, UINT *const nMailPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3847">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3847">
<p><strong>kobj</strong>:: Mail Queue address.</p>
</li>
<li class="data-line-3848">
<p><strong>nMailPtr</strong>:: Pointer to store the retrieved number.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-3852">
<h3 id="stream_queue_2">5.9. Stream Queue</h3>
<div class="sect3 data-line-3855">
<h4 id="kstreaminit">5.9.1. kStreamInit</h4>
<div class="paragraph data-line-3858">
<div class="title">Description</div>
<p>Initialises a Stream Message Queue.</p>
</div>
<div class="listingblock data-line-3863">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamInit(RK_STREAM *const kobj, VOID *bufPtr,
                   const ULONG mesgSizeInWords, const ULONG nMesg);</code></pre>
</div>
</div>
<div class="ulist data-line-3870">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3870">
<p><strong>kobj</strong>:: Stream Queue address.</p>
</li>
<li class="data-line-3871">
<p><strong>bufPtr</strong>:: Allocated memory.</p>
</li>
<li class="data-line-3872">
<p><strong>mesgSizeInWords</strong>:: Message size (min = 1 WORD).</p>
</li>
<li class="data-line-3873">
<p><strong>nMesg</strong>:: Max number of messages.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3875">
<h4 id="kstreamsetowner">5.9.2. kStreamSetOwner</h4>
<div class="paragraph data-line-3878">
<div class="title">Description</div>
<p>Assigns a task owner for the stream queue.</p>
</div>
<div class="listingblock data-line-3882">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamSetOwner(RK_STREAM *const kobj, const RK_TASK_HANDLE taskHandle);</code></pre>
</div>
</div>
<div class="ulist data-line-3887">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3887">
<p><strong>kobj</strong>:: Stream Queue address.</p>
</li>
<li class="data-line-3888">
<p><strong>taskHandle</strong>:: Task handle.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3891">
<h4 id="kstreamsend">5.9.3. kStreamSend</h4>
<div class="paragraph data-line-3894">
<div class="title">Description</div>
<p>Sends a message to a message queue.</p>
</div>
<div class="listingblock data-line-3898">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamSend(RK_STREAM *const kobj, VOID *sendPtr, const RK_TICK timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3903">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3903">
<p><strong>kobj</strong>:: Queue address.</p>
</li>
<li class="data-line-3904">
<p><strong>sendPtr</strong>:: Message address.</p>
</li>
<li class="data-line-3905">
<p><strong>timeout</strong>:: Suspension time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3908">
<h4 id="kstreamrecv">5.9.4. kStreamRecv</h4>
<div class="paragraph data-line-3911">
<div class="title">Description</div>
<p>Receives a message from the queue.</p>
</div>
<div class="listingblock data-line-3915">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamRecv(RK_STREAM *const kobj, VOID *recvPtr, const RK_TICK timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3921">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3921">
<p><strong>kobj</strong>:: Queue address.</p>
</li>
<li class="data-line-3922">
<p><strong>recvPtr</strong>:: Receiving address.</p>
</li>
<li class="data-line-3923">
<p><strong>timeout</strong>:: Suspension time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3927">
<h4 id="kstreampeek">5.9.5. kStreamPeek</h4>
<div class="paragraph data-line-3930">
<div class="title">Description</div>
<p>Receives front message without changing state.</p>
</div>
<div class="listingblock data-line-3934">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamPeek(RK_STREAM const * const kobj, VOID *recvPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3939">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3939">
<p><strong>kobj</strong>:: Stream Queue object.</p>
</li>
<li class="data-line-3940">
<p><strong>recvPtr</strong>:: Receiving pointer.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3944">
<h4 id="kstreamjam">5.9.6. kStreamJam</h4>
<div class="paragraph data-line-3947">
<div class="title">Description</div>
<p>Sends message to queue front.</p>
</div>
<div class="listingblock data-line-3952">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamJam(RK_STREAM *const kobj, VOID *sendPtr, const RK_TICK timeout);</code></pre>
</div>
</div>
<div class="ulist data-line-3958">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3958">
<p><strong>kobj</strong>:: Stream Queue address.</p>
</li>
<li class="data-line-3959">
<p><strong>sendPtr</strong>:: Message address.</p>
</li>
<li class="data-line-3960">
<p><strong>timeout</strong>:: Suspension time.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-3964">
<h4 id="kstreamquery">5.9.7. kStreamQuery</h4>
<div class="paragraph data-line-3967">
<div class="title">Description</div>
<p>Retrieves number of messages in a stream queue.</p>
</div>
<div class="listingblock data-line-3972">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kStreamQuery(RK_STREAM const * const kobj, UINT *const nMesgPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-3977">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3977">
<p><strong>kobj</strong>:: Stream Queue address.</p>
</li>
<li class="data-line-3978">
<p><strong>nMesgPtr</strong>:: Pointer to store the number of messages</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-3980">
<h3 id="most_recent_message_protocol_mrm_2">5.10. Most-Recent Message Protocol (MRM)</h3>
<div class="sect3 data-line-3983">
<h4 id="kmrminit">5.10.1. kMRMInit</h4>
<div class="paragraph data-line-3986">
<div class="title">Description</div>
<p>Initialises an MRM Control Block.</p>
</div>
<div class="listingblock data-line-3990">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMRMInit(RK_MRM *const kobj, RK_MRM_BUF *const mrmPoolPtr,
                VOID *mesgPoolPtr, ULONG const nBufs, ULONG const dataSizeWords);</code></pre>
</div>
</div>
<div class="ulist data-line-3996">
<div class="title">Parameters</div>
<ul>
<li class="data-line-3996">
<p><strong>kobj</strong>:: Pointer to MRM Control Block.</p>
</li>
<li class="data-line-3997">
<p><strong>mrmPoolPtr</strong>:: Pool of MRM buffers.</p>
</li>
<li class="data-line-3998">
<p><strong>mesgPoolPtr</strong>:: Pool of message buffers.</p>
</li>
<li class="data-line-3999">
<p><strong>nBufs</strong>:: Number of MRM Buffers (= number of messages).</p>
</li>
<li class="data-line-4000">
<p><strong>dataSizeWords</strong>:: Size of message in WORDS.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4002">
<h4 id="kmrmreserve">5.10.2. kMRMReserve</h4>
<div class="paragraph data-line-4005">
<div class="title">Description</div>
<p>Reserves an MRM Buffer to be written.</p>
</div>
<div class="listingblock data-line-4009">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_MRM_BUF* kMRMReserve(RK_MRM *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-4014">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4014">
<p><strong>kobj</strong>:: Pointer to MRM Control Block.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4017">
<h4 id="kmrmpublish">5.10.3. kMRMPublish</h4>
<div class="paragraph data-line-4020">
<div class="title">Description</div>
<p>Copies a message into MRM and makes it most recent.</p>
</div>
<div class="listingblock data-line-4024">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMRMPublish(RK_MRM *const kobj, RK_MRM_BUF *const bufPtr, VOID const *dataPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-4030">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4030">
<p><strong>kobj</strong>:: Pointer to MRM Control Block.</p>
</li>
<li class="data-line-4031">
<p><strong>bufPtr</strong>:: Pointer to MRM Buffer.</p>
</li>
<li class="data-line-4032">
<p><strong>dataPtr</strong>:: Pointer to message to publish.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4034">
<h4 id="kmrmget">5.10.4. kMRMGet</h4>
<div class="paragraph data-line-4037">
<div class="title">Description</div>
<p>Receives most recent message within MRM Block.</p>
</div>
<div class="listingblock data-line-4041">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_MRM_BUF* kMRMGet(RK_MRM *const kobj, VOID *getMesgPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-4047">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4047">
<p><strong>kobj</strong>:: Pointer to MRM Control Block.</p>
</li>
<li class="data-line-4048">
<p><strong>getMesgPtr</strong>:: Pointer where message will be copied.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-4051">
<div class="title">Returns</div>
<p>Pointer to MRM Buffer (to be used later with kMRMUnget).
NULL if error.</p>
</div>
</div>
<div class="sect3 data-line-4054">
<h4 id="kmrmunget">5.10.5. kMRMUnget</h4>
<div class="paragraph data-line-4057">
<div class="title">Description</div>
<p>Releases an MRM Buffer after message consumption.</p>
</div>
<div class="listingblock data-line-4061">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMRMUnget(RK_MRM *const kobj, RK_MRM_BUF *const bufPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-4066">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4066">
<p><strong>kobj</strong>:: Pointer to MRM Control Block.</p>
</li>
<li class="data-line-4067">
<p><strong>bufPtr</strong>:: Pointer to MRM Buffer (from kMRMGet).</p>
</li>
</ul>
</div>
<div class="paragraph data-line-4070">
<div class="title">Returns</div>
<p>RK_SUCCESS or specific error.</p>
</div>
</div>
</div>
<div class="sect2 data-line-4073">
<h3 id="time_application_timers_and_delays">5.11. Time, Application Timers and Delays</h3>
<div class="sect3 data-line-4075">
<h4 id="ktickget">5.11.1. kTickGet</h4>
<div class="paragraph data-line-4078">
<div class="title">Description</div>
<p>Gets current system tick count.</p>
</div>
<div class="listingblock data-line-4082">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_TICK kTickGet(VOID);</code></pre>
</div>
</div>
<div class="paragraph data-line-4087">
<div class="title">Returns</div>
<p>Total ticks since system start-up.</p>
</div>
</div>
<div class="sect3 data-line-4089">
<h4 id="ktimerinit">5.11.2. kTimerInit</h4>
<div class="paragraph data-line-4092">
<div class="title">Description</div>
<p>Initialises an application timer.</p>
</div>
<div class="listingblock data-line-4096">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kTimerInit(RK_TIMER *const kobj, const RK_TICK phase,
                  const RK_TICK countTicks, const RK_TIMER_CALLOUT funPtr,
                  VOID *argsPtr, const BOOL reload);</code></pre>
</div>
</div>
<div class="ulist data-line-4103">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4103">
<p><strong>kobj</strong>:: Timer object address.</p>
</li>
<li class="data-line-4104">
<p><strong>phase</strong>:: Initial phase delay (not applied on reload).</p>
</li>
<li class="data-line-4105">
<p><strong>countTicks</strong>:: Time until expiry in ticks.</p>
</li>
<li class="data-line-4106">
<p><strong>funPtr</strong>:: Callout function when timer expires.</p>
</li>
<li class="data-line-4107">
<p><strong>argsPtr</strong>:: Pointer to callout arguments.</p>
</li>
<li class="data-line-4108">
<p><strong>reload</strong>:: TRUE for reload after timeout; FALSE for one-shot.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4112">
<h4 id="ktimercancel">5.11.3. kTimerCancel</h4>
<div class="paragraph data-line-4115">
<div class="title">Description</div>
<p>Cancels an active timer.</p>
</div>
<div class="listingblock data-line-4120">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kTimerCancel(RK_TIMER *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-4126">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4126">
<p><strong>kobj</strong>:: Timer object address.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4129">
<h4 id="ksleep">5.11.4. kSleep</h4>
<div class="paragraph data-line-4132">
<div class="title">Description</div>
<p>Puts current task to sleep for a number of ticks.</p>
</div>
<div class="listingblock data-line-4136">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSleep(const RK_TICK ticks);</code></pre>
</div>
</div>
<div class="ulist data-line-4142">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4142">
<p><strong>ticks</strong>:: Number of ticks to sleep.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4146">
<h4 id="ksleepuntil">5.11.5. kSleepUntil</h4>
<div class="paragraph data-line-4149">
<div class="title">Description</div>
<p>Sleep, compensating any time drifts in-between activations.</p>
</div>
<div class="listingblock data-line-4154">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kSleepUntil(RK_TICK const absTicks);</code></pre>
</div>
</div>
<div class="ulist data-line-4159">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4159">
<p><strong>absTicks</strong>:: Absolute interval in ticks.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4162">
<h4 id="kbusywait">5.11.6. kBusyWait</h4>
<div class="paragraph data-line-4165">
<div class="title">Description</div>
<p>Active wait (busy wait) for a number of ticks.</p>
</div>
<div class="listingblock data-line-4169">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kBusyWait(RK_TICK const ticks);</code></pre>
</div>
</div>
<div class="ulist data-line-4174">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4174">
<p><strong>ticks</strong>:: Number of ticks to wait.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2 data-line-4177">
<h3 id="memory_pool_allocator">5.12. Memory Pool (Allocator)</h3>
<div class="sect3 data-line-4179">
<h4 id="kmeminit">5.12.1. kMemInit</h4>
<div class="paragraph data-line-4182">
<div class="title">Description</div>
<p>Initialises a memory pool control block.</p>
</div>
<div class="listingblock data-line-4187">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMemInit(RK_MEM *const kobj, VOID *memPoolPtr, ULONG blkSize, const ULONG numBlocks);</code></pre>
</div>
</div>
<div class="ulist data-line-4192">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4192">
<p><strong>kobj</strong>:: Pointer to pool control block.</p>
</li>
<li class="data-line-4193">
<p><strong>memPoolPtr</strong>:: Address of memory pool (array of objects).</p>
</li>
<li class="data-line-4194">
<p><strong>blkSize</strong>:: Size of each block (bytes).</p>
</li>
<li class="data-line-4195">
<p><strong>numBlocks</strong>:: Number of blocks.</p>
</li>
</ul>
</div>
</div>
<div class="sect3 data-line-4198">
<h4 id="kmemalloc">5.12.2. kMemAlloc</h4>
<div class="paragraph data-line-4202">
<div class="title">Description</div>
<p>Allocates memory block from pool.</p>
</div>
<div class="listingblock data-line-4206">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">VOID *kMemAlloc(RK_MEM *const kobj);</code></pre>
</div>
</div>
<div class="ulist data-line-4211">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4211">
<p><strong>kobj</strong>:: Pointer to block pool.</p>
</li>
</ul>
</div>
<div class="paragraph data-line-4214">
<div class="title">Returns</div>
<p>Pointer to allocated block, or NULL on failure.</p>
</div>
</div>
<div class="sect3 data-line-4217">
<h4 id="kmemfree">5.12.3. kMemFree</h4>
<div class="paragraph data-line-4220">
<div class="title">Description</div>
<p>Frees a memory block back to pool.</p>
</div>
<div class="listingblock data-line-4224">
<div class="title">Signature</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-c hljs" data-lang="c">RK_ERR kMemFree(RK_MEM *const kobj, VOID *blockPtr);</code></pre>
</div>
</div>
<div class="ulist data-line-4229">
<div class="title">Parameters</div>
<ul>
<li class="data-line-4229">
<p><strong>kobj</strong>:: Pointer to block pool.</p>
</li>
<li class="data-line-4230">
<p><strong>blockPtr</strong>:: Pointer to block to free.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1 data-line-4233">
<h2 id="influences">6. Influences</h2>
<div class="sectionbody">
<div class="paragraph data-line-4235">
<p>For the sake of intellectual honesty and acknowledgment I will list the systems that have inspired RK0 (still incipient) design:</p>
</div>
<div class="ulist data-line-4238">
<ul>
<li class="data-line-4238">
<p>Architecture and features: highly influenced by early <em>Nucleus, ThreadX and uCOS/OS</em>. Which in turn (it seems to me) were influenced by <em>pSOS</em>.</p>
</li>
<li class="data-line-4240">
<p>Doubly linked list ADT: Draws inspiration from the Linux 2.6.x Dlist implementation</p>
</li>
<li class="data-line-4242">
<p>Application timers (Callouts): inspired on 4.4BSD&#8217;s use of delta lists</p>
</li>
<li class="data-line-4244">
<p>MRM Protocol: inspired by <em>HARTIK RTOS</em>.</p>
</li>
</ul>
</div>
<hr>
<div class="imageblock text-center data-line-4249">
<div class="content">
<img src="images/images/mascott.png" alt="mascott" width="10%">
</div>
</div>
<div class="paragraph data-line-4251">
<p>&#169; <em>2025 Antonio Giacomelli | All Rights Reserved | <a href="http://kernel0.org/">www.kernel0.org</a></em></p>
</div>
</div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.3/highlight.min.js"></script>
<script>
if (!hljs.initHighlighting.called) {
  hljs.initHighlighting.called = true
  ;[].slice.call(document.querySelectorAll('pre.highlight > code[data-lang]')).forEach(function (el) { hljs.highlightBlock(el) })
}
</script>
</body>
</html>
