/**
 * RK0 â€” Two Ports communicating (bi-directional RPC)
 *
 * This example sets up two independent Ports, each owned by a server task.
 * Two client tasks issue requests concurrently:
 *   - ClientToA calls ServerA on portA (sum: x+y)
 *   - ClientToB calls ServerB on portB (CRC of a byte buffer)
 * Replies are returned via a 1-word mailbox (kPortSendRecv helper).
 */

#include <application.h>
#include <logger.h>
#include <string.h>

#define STACKSIZE 256
#define PORT_MSG_WORDS 4U   /* meta (2 words) + payload[2] */
#define PORT_CAPACITY 8

/* servers own ports */
static RK_PORT portA; /* ServerA */
static RK_PORT portB; /* ServerB */

RK_DECLARE_PORT_BUF(bufA, PORT_MSG_WORDS, PORT_CAPACITY)
RK_DECLARE_PORT_BUF(bufB, PORT_MSG_WORDS, PORT_CAPACITY)

/* 4-word port message: meta + payload[2] */
typedef RK_PORT_MESG_4WORD Msg4;

/* tasks */
RK_DECLARE_TASK(serverAHandle, ServerATask,   stack1, STACKSIZE)
RK_DECLARE_TASK(serverBHandle, ServerBTask,   stack2, STACKSIZE)
RK_DECLARE_TASK(clientAHandle, ClientToATask, stack3, STACKSIZE)
RK_DECLARE_TASK(clientBHandle, ClientToBTask, stack4, STACKSIZE)

static inline UINT crc32(const void*data, size_t len)
{
    const unsigned char* p = (const unsigned char*)data;
    UINT crc = 0xFFFFFFFFu;
    for (size_t i = 0; i < len; ++i)
    {
        crc ^= p[i];
        for (int b = 0; b < 8; ++b)
            crc = (crc & 1U) ? (crc >> 1) ^ 0xEDB88320u : (crc >> 1);
    }
    return ~crc;
}

VOID kApplicationInit(void)
{
    /* servers are medium prio; clients higher to drive traffic */
    kassert(!kCreateTask(&serverAHandle, ServerATask, RK_NO_ARGS,
                         "SrvA", stack1, STACKSIZE, 5, RK_PREEMPT));
    kassert(!kCreateTask(&serverBHandle, ServerBTask, RK_NO_ARGS,
                         "SrvB", stack2, STACKSIZE, 5, RK_PREEMPT));

    kassert(!kCreateTask(&clientAHandle, ClientToATask, RK_NO_ARGS,
                         "CliA", stack3, STACKSIZE, 3, RK_PREEMPT));
    kassert(!kCreateTask(&clientBHandle, ClientToBTask, RK_NO_ARGS,
                         "CliB", stack4, STACKSIZE, 2, RK_PREEMPT));

    /* init ports (owner=server, server semantics enabled) */
    kassert(!kPortInit(&portA, bufA, PORT_MSG_WORDS, PORT_CAPACITY,
                       serverAHandle));

    kassert(!kPortInit(&portB, bufB, PORT_MSG_WORDS, PORT_CAPACITY,
                       serverBHandle));

    logInit();
}

/* -------- Servers -------- */

/* ServerA: sums two 32-bit operands in payload[0] + payload[1] */
VOID ServerATask(VOID* args)
{
    RK_UNUSEARGS;
    Msg4 msg;
    for(;;)
    {
        kassert(!kPortRecv(&portA, &msg, RK_WAIT_FOREVER));
        UINT x = (UINT)msg.payload[0];
        UINT y = (UINT)msg.payload[1];
        UINT res = x + y;
        logPost("[SrvA] sum(%u,%u)=%u  prio=%d real=%d",
                x, y, res, runPtr->priority, runPtr->prioReal);
        kassert(!kPortReplyDone(&portA, (ULONG const*)&msg, res));
    }
}

/* ServerB: computes CRC32 over a buffer: payload[0]=ptr, payload[1]=len */
VOID ServerBTask(VOID* args)
{
    RK_UNUSEARGS;
    Msg4 msg;
    for(;;)
    {
        kassert(!kPortRecv(&portB, &msg, RK_WAIT_FOREVER));
        const void* ptr = (const void*)msg.payload[0];
        UINT len = (UINT)msg.payload[1];
        UINT crc = crc32(ptr, len);
        logPost("[SrvB] crc(len=%u)=%04X prio=%d real=%d",
                len, crc, runPtr->priority, runPtr->prioReal);
        kassert(!kPortReplyDone(&portB, (ULONG const*)&msg, crc));
    }
}

/* -------- Clients -------- */

/* ClientToA: sends (x,y) to ServerA on portA and logs result */
VOID ClientToATask(VOID* args)
{
    RK_UNUSEARGS;
    RK_MAILBOX reply;
    kMailboxInit(&reply);
    Msg4 msg = {0};
    UINT replyCode = 0;

    UINT x = 1, y = 2;
    for(;;)
    {
        msg.payload[0] = x;
        msg.payload[1] = y;
        kassert(!kPortSendRecv(&portA, (ULONG*)&msg, &reply, &replyCode,
                               RK_WAIT_FOREVER));
        logPost("[CliA] sum(%u,%u) -> %u", x, y, replyCode);
        x += 3; y += 5;
        kSleepDelay(700);
    }
}

/* ClientToB: sends (ptr,len) to ServerB on portB and logs CRC */
VOID ClientToBTask(VOID* args)
{
    RK_UNUSEARGS;
    RK_MAILBOX reply;
    kMailboxInit(&reply);
    Msg4 msg = {0};
    UINT replyCode = 0;

    static unsigned char buf[12] = { 1,2,3,4,5,6,7,8,9,10,11,12 };
    for(;;)
    {
        msg.payload[0] = (ULONG)buf;
        msg.payload[1] = (ULONG)sizeof(buf);
        kassert(!kPortSendRecv(&portB, (ULONG*)&msg, &reply, &replyCode,
                               RK_WAIT_FOREVER));
        logPost("[CliB] crc(buf[12]) -> %04X", replyCode);
        /* mutate buffer a bit */
        buf[0]++;
        buf[5] += 3;
        kSleepDelay(900);
    }
}
