/* SPDX-License-Identifier: Apache-2.0 */
/******************************************************************************
 *
 *                     RK0 — Real-Time Kernel '0'
 *
 * Version          :   V0.5.0
 * Architecture     :   ARMv6/7m
 *
 * Copyright (C) 2025 Antonio Giacomelli
 *
 * Licensed under the Apache License, Version 2.0 (the “License”);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an “AS IS” BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

#include <application.h>

#define STACKSIZE 128

K_DECLARE_TASK(task1Handle, Task1, stack1, STACKSIZE)
K_DECLARE_TASK(task2Handle, Task2, stack2, STACKSIZE)
K_DECLARE_TASK(task3Handle, Task3, stack3, STACKSIZE)

#if (QEMU_MACHINE == lm3s6965evb)
/********** STELLARIS BOARD UART **********/
#include <stdio.h>

#ifndef UART0_BASE
#define UART0_BASE 0x4000C000
#define UART0_DR  (*(volatile unsigned *)(UART0_BASE + 0x00)) /* Data register */
#define UART0_FR  (*(volatile unsigned *)(UART0_BASE + 0x18)) /* Fifo register */
#define UART0_FR_TXFF (1U << 5)   /* FIFO Full */
#endif
 
static inline VOID kPutc(CHAR const c) 
{
	while (UART0_FR & UART0_FR_TXFF)
        ;
    UART0_DR = c;
}

VOID kPuts(const CHAR *str) 
{
     while(*str) 
    {
        kPutc(*str++);
    }
 }
 int _write(int file, char const *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    kPutc(*ptr++);
  }
  return len;
}
#else
static inline VOID kPutc(CHAR const c) 
{
	(VOID)c;
	return;
}

VOID kPuts(const CHAR *str) 
{
	(VOID)str;
	return;
}
#endif
/* Synchronisation Barrier */

typedef struct
{
    RK_MUTEX lock;
    RK_EVENT event;
    UINT count;        /* number of tasks in the barrier */
    UINT round;        /* increased every time all tasks synch     */
} Barrier_t;

VOID BarrierInit(Barrier_t *const barPtr)
{
    kMutexInit(&barPtr->lock, RK_INHERIT);
    kEventInit(&barPtr->event);
    barPtr->count = 0;
    barPtr->round = 0;
}

VOID BarrierWait(Barrier_t *const barPtr, UINT const nTasks)
{
    UINT myRound = 0;
    kMutexLock(&barPtr->lock, RK_WAIT_FOREVER);

    /* save round number */
    myRound = barPtr->round;
    /* increase count on this round */
    barPtr->count++;

    if (barPtr->count == nTasks)
    {
        /* reset counter, inc round, broadcast to sleeping tasks */
        barPtr->round++;
        barPtr->count = 0;
        kCondVarBroadcast(&barPtr->event);
    }
    else
    {
        /* a proper wake signal might happen after inc round */
        while ((UINT)(barPtr->round - myRound) == 0U)
        {
            kCondVarWait(&barPtr->event, &barPtr->lock, RK_WAIT_FOREVER);
        }
    }

    kMutexUnlock(&barPtr->lock);

}


#define N_BARR_TASKS 3

Barrier_t syncBarrier;

VOID kApplicationInit(VOID)
{

    kassert(!kCreateTask(&task1Handle, Task1, RK_NO_ARGS, "Task1", stack1, STACKSIZE, 2, RK_PREEMPT));
    kassert(!kCreateTask(&task2Handle, Task2, RK_NO_ARGS, "Task2", stack2, STACKSIZE, 3, RK_PREEMPT));
    kassert(!kCreateTask(&task3Handle, Task3, RK_NO_ARGS, "Task3", stack3, STACKSIZE, 1, RK_PREEMPT));
	BarrierInit(&syncBarrier);
}
VOID Task1(VOID* args)
{
    RK_UNUSEARGS
    while (1)
    {
        kPuts("Task 1 is waiting at the barrier...\n\r");
        BarrierWait(&syncBarrier, N_BARR_TASKS);
        kPuts("Task 1 passed the barrier!\n\r");
		kSleep(8);

    }
}

VOID Task2(VOID* args)
{
    RK_UNUSEARGS
    while (1)
    {
        kPuts("Task 2 is waiting at the barrier...\n\r");
        BarrierWait(&syncBarrier, N_BARR_TASKS);
        kPuts("Task 2 passed the barrier!\n\r");
		kSleep(5);
	}
}

VOID Task3(VOID* args)
{
    RK_UNUSEARGS
    while (1)
    {
        kPuts("Task 3 is waiting at the barrier...\n\r");
        BarrierWait(&syncBarrier, N_BARR_TASKS);
        kPuts("Task 3 passed the barrier!\n\r");
        kSleep(3);
	}
}

/* SPDX-License-Identifier: Apache-2.0 */
/******************************************************************************
 *
 *                     RK0 — Real-Time Kernel '0'
 *
 * Version          :   V0.5.0
 * Architecture     :   ARMv6/7m
 *
 * Copyright (C) 2025 Antonio Giacomelli
 *
 * Licensed under the Apache License, Version 2.0 (the “License”);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an “AS IS” BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

#include <application.h>
#include <stdlib.h>

#define STACKSIZE 256

K_DECLARE_TASK(task1Handle, Task1, stack1, STACKSIZE)
K_DECLARE_TASK(task2Handle, Task2, stack2, STACKSIZE)

#if (QEMU_MACHINE == lm3s6965evb)
/********** STELLARIS BOARD UART **********/
#include <stdio.h>

#ifndef UART0_BASE
#define UART0_BASE 0x4000C000
#define UART0_DR  (*(volatile unsigned *)(UART0_BASE + 0x00)) /* Data register */
#define UART0_FR  (*(volatile unsigned *)(UART0_BASE + 0x18)) /* Fifo register */
#define UART0_FR_TXFF (1U << 5)   /* FIFO Full */
#endif
 
static inline VOID kPutc(CHAR const c) 
{
	while (UART0_FR & UART0_FR_TXFF)
        ;
    UART0_DR = c;
}

VOID kPuts(const CHAR *str) 
{
     while(*str) 
    {
        kPutc(*str++);
    }
 }
 int _write(int file, char const *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    kPutc(*ptr++);
  }
  return len;
}
#else
static inline VOID kPutc(CHAR const c) 
{
	(VOID)c;
	return;
}

VOID kPuts(const CHAR *str) 
{
	(VOID)str;
	return;
}
#endif
#define kPend(timeout) \
	do { kTaskSignalGet(0x1, RK_FLAGS_ANY, NULL, timeout); } while(0)

#define kSignal(taskhandle) \
	do { kTaskFlagsSet(taskhandle, 0x01); } while(0)

typedef enum
{
	TEMPERATURE=1, HUMIDITY, CO2, FLOW
}SensorType_t;



/* sensor types */
struct sensorMsg
{
    SensorType_t sensorType;
    ULONG sensorValue;

};

typedef struct sensorMsg Mesg_t;

#define N_MESSAGE 8
#define MESSAGE_SIZE (sizeof(Mesg_t))/4 /* WORDS! */
#define N_SENSOR    4
#define AVG_WINDOW_SIZE   10 /* 10 samples */

RK_STREAM sensorStream;/* the stream kobject */
Mesg_t mesgBuf[N_MESSAGE] = {0};/* queue buffer */
RK_TIMER timerT1;
RK_MBOX sensorBox;
static Mesg_t sample = {0};
static UINT sampleErr;
VOID callBackISR( VOID *args)
{
    RK_UNUSEARGS
    sample.sensorType = (rand() % 4) + 1;
    switch (sample.sensorType)
    {
        case TEMPERATURE:
            sample.sensorValue = ( ULONG) rand() % 50;
            break;
        case HUMIDITY:
            sample.sensorValue = ( ULONG) rand() % 100;
            break;
        case CO2:
            sample.sensorValue = ( ULONG) rand() % 1000;
            break;
        case FLOW:
            sample.sensorValue = ( ULONG) rand() % 10;
            break;
        default:
            break;
    }
    RK_ERR err = kMboxPost( &sensorBox, &sample, RK_NO_WAIT);
    if (err != RK_SUCCESS)
        sampleErr ++;

}

VOID kApplicationInit( VOID)
{
    kCreateTask(&task1Handle, Task1, NULL, "Task1", stack1, STACKSIZE, 1, 1);
    kCreateTask(&task2Handle, Task2, NULL, "Task2", stack2, STACKSIZE, 2, 1);
    RK_ERR err = kStreamInit( &sensorStream, ( VOID*) mesgBuf, MESSAGE_SIZE,
    N_MESSAGE);
    kassert( err==RK_SUCCESS);
    err = kTimerInit( &timerT1, 3, 3, callBackISR, NULL, RK_TIMER_RELOAD);
    kassert( err==RK_SUCCESS);
    err = kMboxInit( &sensorBox, NULL, RK_MBOX_REF, 0);
    kassert( err==RK_SUCCESS);
}

VOID Task1( VOID *args)
{
    RK_UNUSEARGS
    Mesg_t *recvSample = NULL;
    while (1)
    {
        RK_ERR errmbox = kMboxPend( &sensorBox, ( VOID**) &recvSample,
                RK_WAIT_FOREVER);
        kassert( errmbox==RK_SUCCESS);
        UINT nMesg = 0;
        kStreamQuery( &sensorStream, &nMesg);
        if (nMesg <= N_MESSAGE - 1)
        {
            RK_ERR err = kStreamSend( &sensorStream, &sample, RK_NO_WAIT);
/* fill up queue and signal consumer task */
            if (err == RK_SUCCESS)
            {
                CHAR const *sensorTypeStr = NULL;
                if (recvSample->sensorType == 1)
                    sensorTypeStr = "TEMP";
                if (recvSample->sensorType == 2)
                    sensorTypeStr = "HUM";
                if (recvSample->sensorType == 3)
                    sensorTypeStr = "CO2";
                if (recvSample->sensorType == 4)
                    sensorTypeStr = "FLOW";

                RK_TICK_DIS
                printf( "ENQ: [@%d, %s, %lu] \n\r", kTickGet(), sensorTypeStr,
                        recvSample->sensorValue);
                RK_TICK_EN
            }
        }
        else
        {
            kSignal( task2Handle);
        }
    }
}

/* for each sensor:
 . a ring buffer of AVG_WINDOW_SIZE values
 . sum of values
 . an index table (=enum - 1 eg., HUMIDITY IDX=2-1=1)
 */
static ULONG ringBuf[N_SENSOR][AVG_WINDOW_SIZE];
static ULONG ringSum[N_SENSOR] = {0};
static UINT ringIndex[N_SENSOR] = {0};

void Task2( void *args)
{

    RK_UNUSEARGS
    Mesg_t readSample;
    while (1)
    {

        RK_ERR err = kStreamRecv( &sensorStream, ( VOID*) &readSample,
        RK_NO_WAIT);
        if (err == RK_SUCCESS)
        {
            UINT sensorIdx = readSample.sensorType - 1;

/* remove oldest sample */
            ULONG oldest = ringBuf[sensorIdx][ringIndex[sensorIdx]];
            ringSum[sensorIdx] -= oldest;

/* push new sample */
            ringBuf[sensorIdx][ringIndex[sensorIdx]] = readSample.sensorValue;
            ringSum[sensorIdx] += readSample.sensorValue;

/* index incr-wrap */
            ringIndex[sensorIdx] ++;
            ringIndex[sensorIdx] %= AVG_WINDOW_SIZE;

/* simple average */
            ULONG avg = ringSum[sensorIdx] / AVG_WINDOW_SIZE;

/* we disable tick to display */
            RK_TICK_DIS

            CHAR const *sensorTypeStr = NULL;
            if (readSample.sensorType == 1)
                sensorTypeStr = "TEMP";
            if (readSample.sensorType == 2)
                sensorTypeStr = "HUM";
            if (readSample.sensorType == 3)
                sensorTypeStr = "CO2";
            if (readSample.sensorType == 4)
                sensorTypeStr = "FLOW";

            printf( "DEQ: [@%d, %s, %lu] | AVG: %lu \n\r", kTickGet(),
                    sensorTypeStr, readSample.sensorValue, avg);

            RK_TICK_EN

        }
        else
        {

             kPend( RK_WAIT_FOREVER);

        }
    }
}/* SPDX-License-Identifier: Apache-2.0 */
/******************************************************************************
 *
 *                     RK0 — Real-Time Kernel '0'
 *
 * Version          :   V0.5.0
 * Architecture     :   ARMv6/7m
 *
 * Copyright (C) 2025 Antonio Giacomelli
 *
 * Licensed under the Apache License, Version 2.0 (the “License”);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an “AS IS” BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

#include <application.h>
#include <stdlib.h>

#define STACKSIZE 256

K_DECLARE_TASK(task1Handle, Task1, stack1, STACKSIZE)
K_DECLARE_TASK(task2Handle, Task2, stack2, STACKSIZE)

#if (QEMU_MACHINE == lm3s6965evb)
/********** STELLARIS BOARD UART **********/
#include <stdio.h>

#ifndef UART0_BASE
#define UART0_BASE 0x4000C000
#define UART0_DR  (*(volatile unsigned *)(UART0_BASE + 0x00)) /* Data register */
#define UART0_FR  (*(volatile unsigned *)(UART0_BASE + 0x18)) /* Fifo register */
#define UART0_FR_TXFF (1U << 5)   /* FIFO Full */
#endif
 
static inline VOID kPutc(CHAR const c) 
{
	while (UART0_FR & UART0_FR_TXFF)
        ;
    UART0_DR = c;
}

VOID kPuts(const CHAR *str) 
{
     while(*str) 
    {
        kPutc(*str++);
    }
 }
 int _write(int file, char const *ptr, int len)
{
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
  {
    kPutc(*ptr++);
  }
  return len;
}
#else
static inline VOID kPutc(CHAR const c) 
{
	(VOID)c;
	return;
}

VOID kPuts(const CHAR *str) 
{
	(VOID)str;
	return;
}
#endif
#define kPend(timeout) \
	do { kTaskSignalGet(0x1, RK_FLAGS_ANY, NULL, timeout); } while(0)

#define kSignal(taskhandle) \
	do { kTaskFlagsSet(taskhandle, 0x01); } while(0)

typedef enum
{
	TEMPERATURE=1, HUMIDITY, CO2, FLOW
}SensorType_t;



/* sensor types */
struct sensorMsg
{
    SensorType_t sensorType;
    ULONG sensorValue;

};

typedef struct sensorMsg Mesg_t;

#define N_MESSAGE 8
#define MESSAGE_SIZE (sizeof(Mesg_t))/4 /* WORDS! */
#define N_SENSOR    4
#define AVG_WINDOW_SIZE   10 /* 10 samples */

RK_STREAM sensorStream;/* the stream kobject */
Mesg_t mesgBuf[N_MESSAGE] = {0};/* queue buffer */
RK_TIMER timerT1;
RK_MBOX sensorBox;
static Mesg_t sample = {0};
static UINT sampleErr;
VOID callBackISR( VOID *args)
{
    RK_UNUSEARGS
    sample.sensorType = (rand() % 4) + 1;
    switch (sample.sensorType)
    {
        case TEMPERATURE:
            sample.sensorValue = ( ULONG) rand() % 50;
            break;
        case HUMIDITY:
            sample.sensorValue = ( ULONG) rand() % 100;
            break;
        case CO2:
            sample.sensorValue = ( ULONG) rand() % 1000;
            break;
        case FLOW:
            sample.sensorValue = ( ULONG) rand() % 10;
            break;
        default:
            break;
    }
    RK_ERR err = kMboxPost( &sensorBox, &sample, RK_NO_WAIT);
    if (err != RK_SUCCESS)
        sampleErr ++;

}

VOID kApplicationInit( VOID)
{
    kCreateTask(&task1Handle, Task1, NULL, "Task1", stack1, STACKSIZE, 1, 1);
    kCreateTask(&task2Handle, Task2, NULL, "Task2", stack2, STACKSIZE, 2, 1);
    RK_ERR err = kStreamInit( &sensorStream, ( VOID*) mesgBuf, MESSAGE_SIZE,
    N_MESSAGE);
    kassert( err==RK_SUCCESS);
    err = kTimerInit( &timerT1, 3, 3, callBackISR, NULL, RK_TIMER_RELOAD);
    kassert( err==RK_SUCCESS);
    err = kMboxInit( &sensorBox, NULL, RK_MBOX_REF, 0);
    kassert( err==RK_SUCCESS);
}

VOID Task1( VOID *args)
{
    RK_UNUSEARGS
    Mesg_t *recvSample = NULL;
    while (1)
    {
        RK_ERR errmbox = kMboxPend( &sensorBox, ( VOID**) &recvSample,
                RK_WAIT_FOREVER);
        kassert( errmbox==RK_SUCCESS);
        UINT nMesg = 0;
        kStreamQuery( &sensorStream, &nMesg);
        if (nMesg <= N_MESSAGE - 1)
        {
            RK_ERR err = kStreamSend( &sensorStream, &sample, RK_NO_WAIT);
/* fill up queue and signal consumer task */
            if (err == RK_SUCCESS)
            {
                CHAR const *sensorTypeStr = NULL;
                if (recvSample->sensorType == 1)
                    sensorTypeStr = "TEMP";
                if (recvSample->sensorType == 2)
                    sensorTypeStr = "HUM";
                if (recvSample->sensorType == 3)
                    sensorTypeStr = "CO2";
                if (recvSample->sensorType == 4)
                    sensorTypeStr = "FLOW";

                RK_TICK_DIS
                printf( "ENQ: [@%d, %s, %lu] \n\r", kTickGet(), sensorTypeStr,
                        recvSample->sensorValue);
                RK_TICK_EN
            }
        }
        else
        {
            kSignal( task2Handle);
        }
    }
}

/* for each sensor:
 . a ring buffer of AVG_WINDOW_SIZE values
 . sum of values
 . an index table (=enum - 1 eg., HUMIDITY IDX=2-1=1)
 */
static ULONG ringBuf[N_SENSOR][AVG_WINDOW_SIZE];
static ULONG ringSum[N_SENSOR] = {0};
static UINT ringIndex[N_SENSOR] = {0};

void Task2( void *args)
{

    RK_UNUSEARGS
    Mesg_t readSample;
    while (1)
    {

        RK_ERR err = kStreamRecv( &sensorStream, ( VOID*) &readSample,
        RK_NO_WAIT);
        if (err == RK_SUCCESS)
        {
            UINT sensorIdx = readSample.sensorType - 1;

/* remove oldest sample */
            ULONG oldest = ringBuf[sensorIdx][ringIndex[sensorIdx]];
            ringSum[sensorIdx] -= oldest;

/* push new sample */
            ringBuf[sensorIdx][ringIndex[sensorIdx]] = readSample.sensorValue;
            ringSum[sensorIdx] += readSample.sensorValue;

/* index incr-wrap */
            ringIndex[sensorIdx] ++;
            ringIndex[sensorIdx] %= AVG_WINDOW_SIZE;

/* simple average */
            ULONG avg = ringSum[sensorIdx] / AVG_WINDOW_SIZE;

/* we disable tick to display */
            RK_TICK_DIS

            CHAR const *sensorTypeStr = NULL;
            if (readSample.sensorType == 1)
                sensorTypeStr = "TEMP";
            if (readSample.sensorType == 2)
                sensorTypeStr = "HUM";
            if (readSample.sensorType == 3)
                sensorTypeStr = "CO2";
            if (readSample.sensorType == 4)
                sensorTypeStr = "FLOW";

            printf( "DEQ: [@%d, %s, %lu] | AVG: %lu \n\r", kTickGet(),
                    sensorTypeStr, readSample.sensorValue, avg);

            RK_TICK_EN

        }
        else
        {

             kPend( RK_WAIT_FOREVER);

        }
    }
}
RK_SEMAPHORE sema;

VOID callBackISR(VOID* ARGS);

VOID kApplicationInit( VOID)
{
    RK_ERR err = kMesgQueueInit(&sensorStream, (VOID*) mesgBuf, MESSAGE_SIZE,
    N_MESSAGE);
    
    kassert(err==RK_SUCCESS);
    
    /* timer @ every 10 ms */
    err = kTimerInit(&timerT1, 0, 10, callBackISR, NULL, RK_TIMER_RELOAD);
    kassert( err==RK_SUCCESS);
    
    err = kMailboxInit(&sensorBox, &slotPtr, 1);
    kassert( err==RK_SUCCESS);
    kCreateTask(&task1Handle, Task1, RK_NO_ARGS, "Task1", stack1, STACKSIZE, 1, RK_PREEMPT);
    kCreateTask(&task2Handle, Task2, RK_NO_ARGS, "Task2", stack2, STACKSIZE, 2, RK_PREEMPT);
     kCreateTask(&logTaskHandle, LoggerTask, RK_NO_ARGS, "LogTsk", logstack, STACKSIZE, 3, RK_PREEMPT);

    kSemaphoreInit(&sema, RK_SEMA_BIN, 0);

     LOG_INIT
}

VOID callBackISR(VOID *args)
{
    RK_UNUSEARGS
    sample.sensorType = (rand() % 4) + 1;
    switch (sample.sensorType)
    {
        case TEMPERATURE:
            sample.sensorValue = ( ULONG) rand() % 50;
            break;
        case HUMIDITY:
            sample.sensorValue = ( ULONG) rand() % 100;
            break;
        case CO2:
            sample.sensorValue = ( ULONG) rand() % 1000;
            break;
        case FLOW:
            sample.sensorValue = ( ULONG) rand() % 10;
            break;
        default:
            kassert(!kMemPoolInit(&qMem, qMemBuf, sizeof(Log_t), LOGBUFSIZ)); \
    break;
    }
    VOID* p = &sample;
    RK_ERR err = kMailboxPostOvw( &sensorBox, &p);
    if (err != RK_SUCCESS)
        sampleErr ++;
    else
    {
        kSemaphoreFlush(&sema);
    }
}

/* Producer - higher priority, XSblocks on mailbox */

VOID Task1(VOID *args)
{
    RK_UNUSEARGS

    while (1)
    {   
        void* recvPtr = NULL;
        kSemaphorePend(&sema, RK_WAIT_FOREVER);
        RK_ERR err = kMailboxPeek( &sensorBox, &recvPtr);
       
        if (err == RK_SUCCESS)
        {
            Mesg_t* recvSample = (Mesg_t*)recvPtr;
            CHAR const *sensorTypeStr = NULL;
            if (recvSample->sensorType == 1)
                sensorTypeStr = "TEMP";
            if (recvSample->sensorType == 2)
                sensorTypeStr = "HUM";
            if (recvSample->sensorType == 3)
                sensorTypeStr = "CO2";
            if (recvSample->sensorType == 4)
                    sensorTypeStr = "FLOW";
            logPost( "1GOT: [%s, %lu] ", sensorTypeStr,
                        recvSample->sensorValue);
        
        }
        
    }
}

VOID Task2(VOID *args)
{
    RK_UNUSEARGS

    while (1)
    {   
        void* recvPtr = NULL;
        kSemaphorePend(&sema, RK_WAIT_FOREVER);
        RK_ERR err = kMailboxPeek( &sensorBox, &recvPtr);
       
        if (err == RK_SUCCESS)
        {

            Mesg_t* recvSample = (Mesg_t*)recvPtr;
            CHAR const *sensorTypeStr = NULL;
            if (recvSample->sensorType == 1)
                sensorTypeStr = "TEMP";
            if (recvSample->sensorType == 2)
                sensorTypeStr = "HUM";
            if (recvSample->sensorType == 3)
                sensorTypeStr = "CO2";
            if (recvSample->sensorType == 4)
                    sensorTypeStr = "FLOW";
            logPost( "2GOT: [%s, %lu] ", sensorTypeStr,
                        recvSample->sensorValue);
        }
    }   
}
 
/RK_DECLARE_TASK(task3Handle, Task3, stack3, STACKSIZE)

#define kPend(timeout)                                \
    do                                                \
    {                                                 \
        kTaskSignalGet(0x1, RK_FLAGS_ANY, NULL, timeout); \
    } while (0)

#define kSignal(taskhandle)           \
    do                                \
    {                                 \
        kTaskFlagsSet(taskhandle, 0x01); \
    } while (0)



typedef enum
{
	TEMPERATURE=1, HUMIDITY, CO2, FLOW
}SensorType_t;



/* sensor types */
struct sensorMsg
{
    SensorType_t sensorType;
    ULONG sensorValue;

};

typedef struct sensorMsg Mesg_t;

#define N_MESSAGE 8
#define MESSAGE_SIZE K_TYPE_SIZE_POW2_WORDS(Mesg_t) /* WORDS! */
#define N_SENSOR    4
#define AVG_WINDOW_SIZE   10 /* 10 samples */

RK_MESG_QUEUE sensorStream;/* the stream kobject */
Mesg_t mesgBuf[N_MESSAGE] = {0};/* queue buffer */
RK_TIMER timerT1;
RK_MAILBOX sensorBox;
static Mesg_t sample = {0};
static UINT sampleErr;

static VOID* slotPtr;


VOID callBackISR(VOID* ARGS);

VOID kApplicationInit(VOID)
{
    logInit();

    RK_ERR err = kMesgQueueInit(&sensorStream, (VOID *)mesgBuf, MESSAGE_SIZE,
                                N_MESSAGE);

    kassert(err == RK_ERR_SUCCESS);

    /* timer @ every 10 ms */
    err = kTimerInit(&timerT1, 0, 10, callBackISR, NULL, RK_TIMER_RELOAD);
    kassert(err == RK_ERR_SUCCESS);

    err = kMailboxInit(&sensorBox, &slotPtr, 1);
    kassert(err == RK_ERR_SUCCESS);
    kCreateTask(&task1Handle, Task1, RK_NO_ARGS, "Task1", stack1, STACKSIZE, 1, RK_PREEMPT);
    kCreateTask(&task2Handle, Task2, RK_NO_ARGS, "Task2", stack2, STACKSIZE, 2, RK_PREEMPT);
}

VOID callBackISR(VOID *args)
{
    RK_UNUSEARGS
    sample.sensorType = (rand() % 4) + 1;
    switch (sample.sensorType)
    {
        case TEMPERATURE:
            sample.sensorValue = ( ULONG) rand() % 50;
            break;
        case HUMIDITY:
            sample.sensorValue = ( ULONG) rand() % 100;
            break;
        case CO2:
            sample.sensorValue = ( ULONG) rand() % 1000;
            break;
        case FLOW:
            sample.sensorValue = ( ULONG) rand() % 10;
            break;
        default:
            break;
    }
    VOID* p = &sample;
    RK_ERR err = kMailboxPost( &sensorBox, &p, RK_NO_WAIT);
    if (err != RK_ERR_SUCCESS)
        sampleErr ++;

}

/* Producer - higher priority, XSblocks on mailbox */

VOID Task1(VOID *args)
{
    RK_UNUSEARGS

    while (1)
    {   
        void* recvPtr = NULL;
        RK_ERR errmbox = kMailboxPend( &sensorBox, &recvPtr,
                RK_WAIT_FOREVER);
        kassert( errmbox==RK_ERR_SUCCESS);

        Mesg_t *recvSample = (Mesg_t*)recvPtr;
         RK_ERR err = kMesgQueueSend( &sensorStream, recvSample, RK_NO_WAIT);
        kassert(err >= 0); /* either succesful or unsuccesful */
        if (err == RK_ERR_SUCCESS)
        {
            CHAR const *sensorTypeStr = NULL;
            if (recvSample->sensorType == 1)
                sensorTypeStr = "TEMP";
            if (recvSample->sensorType == 2)
                sensorTypeStr = "HUM";
            if (recvSample->sensorType == 3)
                sensorTypeStr = "CO2";
            if (recvSample->sensorType == 4)
                    sensorTypeStr = "FLOW";
            logPost( "ENQ: [%s, %lu] ", sensorTypeStr,
                        recvSample->sensorValue);
        }
        else if (err == RK_ERR_MESGQ_FULL) 
        {
            kSignal(task2Handle);
        }
    }
}

/* for each sensor:
     . a ring buffer of AVG_WINDOW_SIZE values
 . sum of values
 . an index table (=enum - 1 eg., HUMIDITY IDX=2-1=1)
 */
static ULONG ringBuf[N_SENSOR][AVG_WINDOW_SIZE];
static ULONG ringSum[N_SENSOR] = {0};
static UINT ringIndex[N_SENSOR] = {0};

void Task2( void *args)
{

    RK_UNUSEARGS
    Mesg_t readSample;
    while (1)
    {
        RK_ERR err = kMesgQueueRecv(&sensorStream, (VOID*)&readSample,
        RK_NO_WAIT);
        if (err == RK_ERR_SUCCESS)
        {
            UINT sensorIdx = readSample.sensorType - 1;

/* remove oldest sample */
            ULONG oldest = ringBuf[sensorIdx][ringIndex[sensorIdx]];
            ringSum[sensorIdx] -= oldest;

/* push new sample */
            ringBuf[sensorIdx][ringIndex[sensorIdx]] = readSample.sensorValue;
            ringSum[sensorIdx] += readSample.sensorValue;

/* index incr-wrap */
            ringIndex[sensorIdx] ++;
            ringIndex[sensorIdx] %= AVG_WINDOW_SIZE;

/* simple average */
            ULONG avg = ringSum[sensorIdx] / AVG_WINDOW_SIZE;


            CHAR const *sensorTypeStr = NULL;
            if (readSample.sensorType == 1)
                sensorTypeStr = "TEMP";
            if (readSample.sensorType == 2)
                sensorTypeStr = "HUM";
            if (readSample.sensorType == 3)
                sensorTypeStr = "CO2";
            if (readSample.sensorType == 4)
                sensorTypeStr = "FLOW";

            logPost( "DEQ: [%s, %lu] | AVG: %lu",
                    sensorTypeStr, readSample.sensorValue, avg);

        }
        else
        {
            kPend(RK_WAIT_FOREVER);
        }

    }
}
#include <application.h>
#include <stdio.h>

/*---------- config ----------*/
#define STACKSIZE 256

/*---------- tasks ----------*/
RK_DECLARE_TASK(serverHandle,  ServerTask,  stack1, STACKSIZE)
RK_DECLARE_TASK(client1Handle, Client1Task, stack2, STACKSIZE)
RK_DECLARE_TASK(client2Handle, Client2Task, stack3, STACKSIZE)

/*---------- message type (passed by pointer) ----------*/
typedef struct {
    UINT        clientId;     /* 1 or 2 */
    UINT        req;          /* request number */
    UINT        resp;         /* server fills this */
    RK_MAILBOX* replyMbox;    /* where server replies */
} Msg K_ALIGN(4);

/*---------- 1-word mailboxes (carry pointers/UINTs by value) ----------*/
static ULONG serverReqSlot[1], serverAckSlot[1], client1Slot[1], client2Slot[1];
static RK_MAILBOX serverReqMbox;   /* Msg* from clients */
static RK_MAILBOX serverAckMbox;   /* UINT ack from clients */
static RK_MAILBOX clientMbox1;     /* Msg* to client 1   */
static RK_MAILBOX clientMbox2;     /* Msg* to client 2   */

VOID kApplicationInit(void)
{
    kassert(!kCreateTask(&serverHandle,  ServerTask,  RK_NO_ARGS, "Server",  stack1, STACKSIZE, 1, RK_PREEMPT));
    kassert(!kCreateTask(&client1Handle, Client1Task, RK_NO_ARGS, "Client1", stack2, STACKSIZE, 2, RK_PREEMPT));
    kassert(!kCreateTask(&client2Handle, Client2Task, RK_NO_ARGS, "Client2", stack3, STACKSIZE, 2, RK_PREEMPT));

    /* by-copy mailbox with 1-word slots → carries pointers/UINTs */
    kassert(!kMailboxInit(&serverReqMbox, serverReqSlot, 1));
    kassert(!kMailboxInit(&serverAckMbox, serverAckSlot, 1));
    kassert(!kMailboxInit(&clientMbox1,  client1Slot,   1));
    kassert(!kMailboxInit(&clientMbox2,  client2Slot,   1));

    /* optional: boost the server when writers block on full request mbox */
    /* kassert(!kMailboxSetOwner(&serverReqMbox, serverHandle)); */
}

/*---------- Server: recv Msg*, compute resp, reply with Msg*, wait ACK ----------*/
VOID ServerTask(void *args)
{
    RK_UNUSEARGS;

    for (;;)
    {
        Msg *m = NULL;

        /* Receive pointer to client message */
        kassert(!kMailboxPend(&serverReqMbox, &m, RK_WAIT_FOREVER));

        /* Simple “work”: resp = req + 1000 (no strings involved) */
        m->resp = m->req + 1000;

        /* Reply: send the same pointer back to the client's reply mailbox */
        Msg *respPtr = m;
        kassert(!kMailboxPost(m->replyMbox, &respPtr, RK_WAIT_FOREVER));

        /* Wait for client ACK (single UINT by value) */
        UINT ack = 0;
        kassert(!kMailboxPend(&serverAckMbox, &ack, RK_WAIT_FOREVER));

        printf("[SERVER] served client=%u  req=%u  resp=%u  ack=%u\n",
               m->clientId, m->req, m->resp, ack);
    }
}

/*---------- Client 1 ----------*/
VOID Client1Task(void *args)
{
    RK_UNUSEARGS;

    Msg m;
    m.clientId  = 1;
    m.replyMbox = &clientMbox1;

    while(1)
    {
        for (UINT seq = 0;; ++seq)
        {
            m.req = seq;

            /* Send pointer to request */
            Msg *p = &m;
            kassert(!kMailboxPost(&serverReqMbox, &p, RK_WAIT_FOREVER));

            /* Wait for pointer to reply (same struct) */
            Msg *r = NULL;
            kassert(!kMailboxPend(&clientMbox1, &r, RK_WAIT_FOREVER));

            printf("[C1] req=%u  resp=%u\n", r->req, r->resp);

            /* Ack the server with our client id (one word) */
            UINT ack = 1;
            kassert(!kMailboxPost(&serverAckMbox, &ack, RK_WAIT_FOREVER));

        }

    kSleepDelay(80); /* pacing so you can read the prints */
   
    }
}
/*---------- Client 2 ----------*/
VOID Client2Task(void *args)
{
    RK_UNUSEARGS;

    Msg m;
    m.clientId  = 2;
    m.replyMbox = &clientMbox2;

    while(1)
    {
        for (UINT seq = 100;; ++seq)    /* different sequence to distinguish */
        {
            m.req = seq;

            Msg *p = &m;
            kassert(!kMailboxPost(&serverReqMbox, &p, RK_WAIT_FOREVER));

            Msg *r = NULL;
            kassert(!kMailboxPend(&clientMbox2, &r, RK_WAIT_FOREVER));

            printf("[C2] req=%u  resp=%u\n", r->req, r->resp);

            UINT ack = 2;
            kassert(!kMailboxPost(&serverAckMbox, &ack, RK_WAIT_FOREVER));
        }
    }
    kSleepDelay(120);
}
