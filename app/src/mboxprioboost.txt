/**
 *
 *
 *                     RK0 — Real-Time Kernel '0'
 *
 * Version          :   V0.8.0
 * Architecture     :   ARMv6/7m
 *
 * Copyright (C) 2025 Antonio Giacomelli
 *
 * Licensed under the Apache License, Version 2.0 (the “License”);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an “AS IS” BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 ******************************************************************************/

#include <application.h>
#include <logger.h>
#include <stdlib.h>
#include <kstring.h>

/******************************************************************************/
/* APPLICATION                                                                */
/******************************************************************************/
#define STACKSIZE 512

/**** Declaring tasks's required data ****/

/* 4-word payload (e.g., UINT[4]) */
static UINT mbSlot[4];
static RK_MESG_QUEUE mbox; 

/* rk0 mailbox owner-boost demo (copy-only mailbox)
 * Run twice: OWNER_ON=0 (baseline) and OWNER_ON=1 (boost)*/
 

/* ---------- compile-time switches ---------- */
#define OWNER_ON          1      /* 0: no owner; 1: consumer is owner */

/* ---------- demo timing scale (ms) ---------- */
#define SCALE_MS(x)       ((x) * 25)   /* bump to 50/100 if prints are slow */

/* "logical" times, scaled above to help semihosting I/O keep up */
#define PRODUCER_PERIOD   SCALE_MS(10)   /* producer pacing between posts */
#define CONSUMER_SLICE    SCALE_MS(1)    /* consumer work slice (kept RUNNABLE) */
#define HOG_WORK          SCALE_MS(12)   /* hog CPU spin each loop */
#define HOG_SLEEP         SCALE_MS(2)    /* tiny sleep to let tick/IO run */


/* ---------- knobs ---------- */
#define PRINT_EVERY    2
#define PRODUCER_SLEEP 25  /* ms, pacing so prints show up */

 
/* ---------- tasks ---------- */
RK_DECLARE_TASK(producerHandle, ProducerTask, stack1, STACKSIZE)
RK_DECLARE_TASK(consumerHandle, ConsumerTask, stack2, STACKSIZE)
RK_DECLARE_TASK(hogHandle,      HogTask,      stack3, STACKSIZE)

 

VOID kApplicationInit(void)
{
        RK_ERR e;

    /* priorities: producer=1 (high), hog=2 (mid), consumer=3 (low) */
    e = kCreateTask(&producerHandle, ProducerTask, RK_NO_ARGS,
                    "Producer", stack1, STACKSIZE, 1, RK_PREEMPT);
    kassert(e == RK_ERR_SUCCESS);

    e = kCreateTask(&hogHandle, HogTask, RK_NO_ARGS,
                    "Hog",      stack3, STACKSIZE, 2, RK_PREEMPT);
    kassert(e == RK_ERR_SUCCESS);

    e = kCreateTask(&consumerHandle, ConsumerTask, RK_NO_ARGS,
                    "Consumer", stack2, STACKSIZE, 3, RK_PREEMPT);
    kassert(e == RK_ERR_SUCCESS);


    /* init COPY mailbox: 4 words (16 bytes) */
    kassert(!kMesgQueueInit(&mbox, mbSlot, /*slotSizeWords=*/4, 1));

#if OWNER_ON
    kassert(!kMesgQueueSetOwner(&mbox, consumerHandle));
#endif

    logInit();
}

 
/* rolling metrics so we don’t print every time */
static struct {
    ULONG samples, sum_ms, max_ms, min_ms;
} M = {0,0,0,~0u};

/* helper */
static inline void rec_block_ms(ULONG dt){
    M.samples++;
    M.sum_ms += dt;
    if (dt > M.max_ms) M.max_ms = dt;
    if (dt < M.min_ms) M.min_ms = dt;
    if ((M.samples % PRINT_EVERY)==0){
        logPost("blocked_ms: last=%lu  avg=%lu  min=%lu  max=%lu  n=%lu ",
               dt, M.sum_ms/M.samples, M.min_ms, M.max_ms, M.samples);
    }
}

/* High-priority producer: ALWAYS causes 1 block per loop */
VOID ProducerTask(void* args){
    RK_UNUSEARGS;
    UINT seq=0;
    for(;;){

        UINT msg[4] = { seq, 0x00, 0x00, 0xCC };
        
        logPost("Prod task enter");

        /* 1) First post: usually immediate, fills the slot */
        kassert(!kMesgQueueSend(&mbox, msg, RK_WAIT_FOREVER));
        logPost("Prod task sent seq: 0x%02X", seq);

        msg[1] = 0xAB;
        /* 2) Second post: must block until Consumer drains the first */
        RK_TICK t1 = kTickGetMs();
        kassert(!kMesgQueueSend(&mbox, msg, RK_WAIT_FOREVER));
        ULONG dt = (ULONG)(kTickGetMs() - t1);

        /* stats (print every N) */
        rec_block_ms(dt);

        seq++;
        kSleep(PRODUCER_SLEEP);
 
    }
}
/* Low-priority consumer (OWNER when OWNER_ON=1).
 * Does 'work' in SHORT SLICES (spin) so it stays RUNNABLE (not sleeping).
 * That way, when Producer blocks on FULL, owner-boost can preempt the Hog. */
VOID ConsumerTask(VOID *args)
{
    RK_UNUSEARGS;

    for (;;) {
        UINT rx[4] = {0};

        logPost("Cons enter");
        /* COPY pend: data is memcpy'd into rx[] */
        kassert(!kMesgQueueRecv(&mbox, rx, RK_WAIT_FOREVER));
        /* simulate compute but KEEP TASK RUNNABLE (no sleep here) */
        logPost("Cons recvd: [0x%02X,0x%02X,0x%02X,0x%02X]", rx[0], rx[1], rx[2], rx[3]);
        kDelay(CONSUMER_SLICE);

        
        
     }
}

/* Mid-priority hog that keeps CPU busy (with tiny sleeps for tick/IO). */
VOID HogTask(VOID *args)
{
    RK_UNUSEARGS;
    for (;;) 
    {
        logPost("Hog task running");
        kDelay(HOG_WORK);
        kSleepDelay(HOG_SLEEP);   /* small yield so other things progress */
    }
}
